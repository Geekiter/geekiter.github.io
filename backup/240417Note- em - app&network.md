# 1. 进程&线程
## 1.1 异步IO和同步IO区别？

如果是同步IO，当一个IO操作执行时，应用程序必须等待，直到此IO执行完。相反，异步IO操作在后台运行，IO操作和应用程序可以同时运行，提高系统性能，提高IO流量。

在同步文件IO中，线程启动一个IO操作然后进入等待状态，直到IO操作完成后才醒来继续执行。而异步文件IO中，线程发送一个IO请求到内核，然后继续处理其他事情，内核完成IO请求，将会通知线程IO操作完成。

## 1.2 进程间通信


| 方式                | 解释                                                                                          |
| ----------------- | ------------------------------------------------------------------------------------------- |
| 管道，pipe           | 是 一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用，通常是父子进程                                            |
| 有名管道，named pipe   | 也是半双工通信方式，但是它允许用于无亲缘关系的进程之间的通信                                                              |
| 信号量semaphore      | 是一个计数器，通常作为一个同步机制，用于进程和线程间的同步                                                               |
| 消息队列message queue | 是一个消息链表，存放在内核中并且由消息队列标识符标识。消息队列克服了信号传递信号少、管道只能承载无格式字节流以及缓存区大小受限的缺点                          |
| 共享内存shared memory | 一段能够被多个进程共同访问的内存，由一个进程创建。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而设计的，往往与其他通信方式如信号量配合使用，来实现进程间同步和通信 |
| 套接字socket         | 可用于不同主机间的进程通信                                                                               |
| 信号signal          | 用于通知接收进程某个事件已经发生，是一种比较复杂的通信方式                                                               |

## 1.3 进程的地址空间模型
![[Pasted image 20240417100925.png]]
- text segment
	- 存储代码的区域
- data segment
	- 存储初始化不为0的全局变量和静态变量、const型常量
- bss segment
	- 存储未初始化的、初始化位0的全局变量和静态变量
- heap堆
	- 用于动态开辟内存空间
- memory mapping space内存映射区
	- mmap系统调用使用的空间，通常用于文件映射到内存或匿名映射
- stack栈
	- 存储函数参数、局部变量
- kernel space
	- 存储内核代码

## 1.4 进程的五种状态分别是？

![[Pasted image 20240417101258.png]]

- 就绪态：所有运行条件已经就绪，只要得到了CPU时间就可以运行
- 运行态：得到CPU时间正在运行
- 僵尸态：进程已经结束了但父进程还没来得及回收
- 等待态：包括浅度睡眠和深度睡眠
- 暂停态：暂时停止参与CPU调度，即条件成熟，可以恢复

## 1.5 子进程从父进程继承的资源有
- 子进程继承父进程的绝大部分资源，包括堆栈、内存、用户号和组号、打开的文件描述符、当前工作目录、根目录
- 子进程独有进程号、不同的父进程号、自己的文件描述符

## 1.6 什么是进程上下文、中断上下文

- 进程上文：是指进程由用户态切换到内核态时需要保存用户态CPU寄存器中的值，进程状态以及堆栈上的内容，即保存当前进程的状态，以便再此执行该进程，能够恢复切换时的状态，继续执行
- 进程下文：是指切换到内核态后执行的程序，即进程运行在内核空间的部分
- 中断上文：硬件通过中断触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。中断上文可以看着是硬件传递过来的参数和内核需要保存的一些其他环境
- 中断下文：执行在内核空间的中断服务程序

## 1.7 如何防止僵尸进程过多导致系统空间爆满？

每当子进程退出，父进程都会收到SIAGCHLD信号，故可在父进程中设置SIGCHLD信号的捕获函数，在捕获函数中回收子进程
```c
void handler(int sig){
	int status;
	if(waitpid(-1, &status, WNOHANG) >= 0){
		printf("child is die\n");
	}
}

int main(){
	signal(SIGCHLD, handler);
	int pid = fork();
	if(pid > 0){
		while(1){
			sleep(2);
		}
	}
	else if(0 == pid){
		printf("i am child, i die");
		exit(0);
	}
}
```

- 僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程
- 可用top命令查看僵尸进程的数量zombie，页可以用ps -aux | grep Z 僵尸进程的状态显示位Z来查看僵尸进程的PID信息

## 1.8 /proc目录下，以数字命名的目录表示什么？
以数字命名的目录表示当前一个运行的进程，目录名即为进程PID，其内的目录和文件给出了一些关于该进程的信息

## 1.9 进程和线程有什么区别

- 进程是系统中程序执行和资源分配的基本单位，线程是CPU调度的基本单位
- 一个进程拥有多个线程，线程可以访问其所属进程地址空间和系统资源（数据段
、已经打开的文件、I/O设备等），同时也拥有自己的堆栈
- 同一进程中的多个线程可以共享同一地址空间，因此它们之间的通信实现也比较简单，而且切换开销小、创建和消亡的开销也小。而进程间的通信则比较麻烦，而且进程切换开销、进程创建和消亡开销较大。

## 1.10 什么时候用多进程？什么时候用多线程？
- 当程序的安全性、稳定性要求较高时用多进程
- 需要频繁/切换程序/创建和销毁程序时用多线程

## 1.11 线程可以独立运行吗？
线程不能独立运行，但一个线程的崩溃不一定导致整个进程崩溃

- 线程数据进程，线程的运行需要依赖进程的地址空间和系统资源
- 线程崩溃的本质就是内存出错，若出错的内存没有被其他线程访问，则不会导致其他线程出错，也就不会导致进程崩溃

## 1.12 写出下列线程、互斥锁、信号量的相关代码

| 定义一个线程ID变量    | pthread_t tid;                                  |
| ------------- | ----------------------------------------------- |
| 创建线程          | pthread_create(&tid, NULL, pthread_func, NULL)  |
| 等待子线程结束，并回收资源 | pthread_join(tid, NULL);                        |
| 与当前进程分离       | pthread_detach(tid);                            |
| 退出调用线程        | pthread_exit(NULL);                             |
| 取消线程          | pthread_cancel(tid);                            |
| 创建互斥锁         | pthread_mutex mutex = PTHREAD_MUTEX_INITIALIZER |
| 初始化一个互斥锁      | pthread_mutex_init(&mutex, NULL);               |
| 对互斥锁上锁        | pthread_mutex_lock(&mutext);                    |
| 对互斥锁解锁        | pthread_mutex_unlock(&mutex);                   |
| 定义一个信号量       | sem_t sem;                                      |
| 创建信号量并初始化它的值  | sem_init(&sem, 0, 1);                           |
| 信号量的值减1       | sem_wait(&sem);                                 |
| 信号量的值加1       | sem_post(&sem);                                 |

## 1.13 线程间通信和同步方式有哪些？
信号、信号量、互斥锁、条件变量、自旋锁、读写锁

## 1.14 如何防止同时产生大量的线程

- 使用线程池
- 线程池可以提高调度效率和限制资源使用，线程池中的线程达到最大数时，其他线程就会排队等候

## 1.15 互斥锁与信号量的区别？
- 信号量用于线程同步，互斥锁用于线程互斥
- 信号量可以为非负整数，可以实现多个同类资源的多线程同步；互斥锁只能为0/1，只能用于一个资源的互斥访问
- 信号量可以由一个线程释放，另一个线程得到；互斥锁的加锁和解锁必须由同一线程分别对应使用，且多个线程使用多个互斥锁必须注意统一顺序，否则可能造成死锁

## 1.16 孤儿进程是什么？
- 父进程先于子进程结束，此时子进程成为一个孤儿进程
- Linu系统规定：所有孤儿进程都成为一个特殊进程，进程1，也就是init进程的子进程


# 2 网络编程
## 2.1 列举一下OSI协议的各种分层

| 层     | 功能                                                |
| ----- | ------------------------------------------------- |
| 应用层   | 在实现多个应用进程相互通信的同时，完成一系列业务处理所需的服务，比如电子邮件、文件传输、远程登录等 |
| 表示层   |                                                   |
| 会话层   |                                                   |
| 传输层   |                                                   |
| 网络层   |                                                   |
| 数据链路层 |                                                   |
| 物理层   |                                                   |

## 2.2 TCP/IP协议包括？

| 层     | 协议           |
| ----- | ------------ |
| 应用层   | FTP、SMTP、DNS |
| 传输层   | UDP、TCP      |
| 网络层   | IP、ICMP、IGMP |
| 网络接口层 | ARP、RARP     |

## 2.3 TCP通信建立和释放的过程？端口的作用？

- 连接是三次握手，释放是四次挥手
- 端口是一个软件结构，被客户进程或服务进程用来发送和接收信息。一个端口对应一个16比特的数。服务进程通常使用一个固定的端口。

## 2.4 IP地址转换成物理地址的协议？反之？

- 将IP地址转换成物理地址的协议是ARP，地址解析协议
- 反之则是RARP，反地址解析协议

## 2.5 IP地址的编码分为哪两个部分？
IP地址由两部分组成，网络号和主机号。不过是要和子网掩码按位与上之后才能区分哪些是网络位哪些是主机位

## 2.6 应用程序ping发出的是什么报文

应用程序ping发出的是ICMP请求报文
ping的原理是利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，通过对方恢复的数据包来确定两台机器是否连接相通，时延是是多少

## 2.7 socket编程的流程是？
- 服务端流程
	- socket()：创建套接字
	- bind()：绑定本地IP地址和端口号
	- listen()：设置监听队列长度
	- accept()：等待连接
	- read()：接收信息
	- close()：关闭套接字
- 客户端流程：
	- socket()：创建套接字
	- connect()：发送链接请求
	- write()：发送套接字
	- close()：关闭套接字

## 2.8 epoll是什么？
- epoll是Linux网络编程中用于批量处理大批量文件描述符的机制，是对select/poll的改进
- select监听的fd是有上限的，32位处理器一般位1024，且select/poll每次调用都会遍历所有fd，时间复杂度为O(n)，效率太低。而epoll监听的fd数量没有限制，且能在O(1)的时间复杂度内完成操作
- epoll相关的系统调用有：epoll_creat，epoll_ctl，epoll_wait/epoll_pwait可屏蔽特定信号，分别用来创建一个epoll文件描述符，添加/删除/修改需要侦听的文件描述符及事件、接收被侦听描述符的IO事件。epoll文件描述符用完之后直接close关闭即可。

## 2.9 TCP、UDP的区别？
- TCP是面向连接的、UDP是面向无连接的
- TCP是面向字节流的、UDP是基于数据报的
- TCP提供可靠服务，正确性、顺序性，UDP提供不可靠服务
- TCP结构复杂，占用资源多；UDP程序结构简单，占用资源少
- TCP由拥塞控制，UDP没有，因此网络出现拥塞不会使源主机的发送速率降低，适合于实时应用，如IP电话、实时视频会议
- TCP只支持一对一；UDP支持一对一，一对多，多对一，多对多

## 2.10 TCP、UDP分别有什么优点和缺点？
- TCP
	- 优点：稳定可靠
	- 缺点：效率低、占用系统资源多、易受攻击
- UDP
	- 优点：效率高、占用系统资源少
	- 缺点：不稳定、不可靠

## 2.11 TCP、UDP各自的适用场景
- TCP：对数据传输质量要求较高对实时性要求不高的场景，比如HTTP、HTTPS、FTP等文件传输协议
- UDP：对数据传输的实时性要求较高，对质量要求不高，比如在线视频

## 2.13 TCP如何保证可靠传输

- 校验和：发送数据报的二进制相加然后取反，检测数据在传输过程中的变化，有差错则丢弃
- 确认应答：接收方收到正确的报文就会确认
- 超时重传：发送方等待一定时间后没有收到确认报文则重传
- 序列号：发送方对每一个数据包编号，接收方对数据包排序，保证不乱序，不重复
- 窗口机制，流量控制，双方会协调发送的数据包大小，保证接收方能及时接收
- 拥塞控制机制：如果网络拥塞，发送方会降低发送速率，降低整个网络的拥塞程度
- 总结：校验和、确认应答、超时重传、序列号、窗口机制、拥塞控制机制

## 2.14 简述TCP三次握手的过程
![[Pasted image 20240417113955.png]]

- 第一次握手：客户端发送SYN
- 第二次握手：服务器发送ACK，SYN
- 第三次握手：发送ACK报文

## 2.15 为什么需要三次握手

- 三次握手是为什么防止已经失效的连接请求报文突然传输到了服务器，从而建立错误的连接
- 防止死锁。

## 2.16 为什么服务器端易受SYN攻击？
- 因为服务器端的资源是在第二次握手时分配的，而客户端的资源是在第三次握手时才分配的，若服务器收到大量伪造的IP地址发来的SYN包，则需要不断回复并等待确认，有等待不到确认这些连接就会占满未连接队列，导致后来正常的请求报文被丢弃，从而引起网络拥塞甚至系统瘫痪
- 防范措施：现在单个ip地址的最大连接数、限制单位时间内连接数

## 2.17 简述TCP四次挥手的过程
![[Pasted image 20240417114654.png]]
- 第一次挥手：客户端发出连接释放报文FIN=1，seq=u
- 第二次挥手：服务器发出ACK=1
- 第三次挥手：服务器发送完报文，FIN=1，ACK=1
- 第四次挥手：客户端发出ACK=1

## 2.18 TCP四次挥手中，为什么客户端最后还要等待2\*MSL Maximun Segment Lifetime

- 保证客户端发送的最后ACK能够到达服务器
- 使本次链接持续的时间内所产生的所有报文段都从网络中消失

## 2.19 为什么连接是三次握手，关闭是四次挥手？

- 建立连接：服务器在LISTEN状态下不需要等待既可以建立连接
- 关闭链接，需要等服务器将所有未发完的数据都发完，所以服务器的确认报文和连接释放报文一般分开发送

## 2.20 DNS服务器和客户机设置完毕后，有哪三个命令可以测试其设置是否正确？
- PING
- IPCONFIG
- NSLOOKUP：查询DNS记录

## 2.21 网络编程的作用？
本质是用套接字进行进程间通信，但是这些进程是分布在不同主机上的进程，因此网络编程在物联网方面有比较大的作用

## 2.22 socket网络编程中，哪5个元素可以明确标识一条连接？
五元组：客户端端口、客户端IP、服务端端口、服务端IP、传输协议

## 2.23 什么是TCP粘包？
发送方发送的若干数据包到达接收方粘成一个包

## 2.24 TCP粘包的原因

同上

## 2.25 什么时候处理粘包现象

- 如果发送方发送的多组数据本来就是同一块数据的不同部分，这时候不需要
- 反之需要处理
## 2.26如何解决粘包？
- 发送方：关闭Nagle算法
- 接收方：交给应用层处理
- 应用层：格式化数据

## 2.27 IP地址分类

A：政府机关
B：中等规模企业
C：任何
D：多播
E：实验


## IP地址和MAC地址的相同点和不同点？
- 相同点：都是唯一的
- 不同点：
	- 分配依据不同
		- IP地址基于网络拓扑设计，可以改动
		- MAC基于制造商，不能改动
	- 长度不同：IP地址位32位，MAC地址位48位
	- 寻址协议不同
		- IP地址位于第三层，网络层
		- MAC地址位于第二层，数据链路层

## 2.29 路由器、交换机、集线器的区别
- 路由器工作在网络层，根据网络层提供的信息IP地址来选择路由
- 交换机工作在数据链路层，通过数据链路层提供的信息MAC地址来选择端口
- 集线器工作在物理层，只对信号进行整形，放大后再重发
