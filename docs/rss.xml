<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Geekiter</title><link>https://blog.chenkeyan.com</link><description>ExploreX, To be myself.</description><copyright>Geekiter</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/20443506?v=4</url><title>avatar</title><link>https://blog.chenkeyan.com</link></image><lastBuildDate>Thu, 18 Apr 2024 09:16:18 +0000</lastBuildDate><managingEditor>Geekiter</managingEditor><ttl>60</ttl><webMaster>Geekiter</webMaster><item><title>240418Note: fe - handwritten question</title><link>https://blog.chenkeyan.com/post/240418Note-%20fe%20-%20handwritten%20question.html</link><description>### 1. 手写 Object.create&#13;
```js&#13;
function create(obj){&#13;
	function F(){}&#13;
	F.prototype = obj;&#13;
	return new F()&#13;
}&#13;
&#13;
function create(obj){&#13;
	function F(){}&#13;
	F.prototype = obj;&#13;
	return new F()&#13;
}&#13;
&#13;
function create(obj){&#13;
	function F(){}&#13;
	F.prototype = obj;&#13;
	return new F()&#13;
}&#13;
&#13;
function create(obj){&#13;
	function F(){}&#13;
	F.prototype = obj;&#13;
	return new F()&#13;
}&#13;
```&#13;
&#13;
### 2. 手写 instanceof 方法&#13;
&#13;
```js&#13;
function myInstanceof(left, right){&#13;
	let proto = Object.getPrototypeOf(left);&#13;
	prototype = right.prototype;&#13;
	while(true){&#13;
		if(!proto) return false;&#13;
		if(proto === prototype) return true;&#13;
		proto = Object.getPrototypeOf(proto);&#13;
	}&#13;
}&#13;
function myInstanceof(left, right){&#13;
	let proto = Object.getPrototypeOf(left);&#13;
	prototype = right.prototype;&#13;
	while(true){&#13;
		if(!proto) return false;&#13;
		if(proto === prototype) return true;&#13;
		proto = Object.getPrototypeOf(proto);&#13;
	}&#13;
}&#13;
&#13;
function myInstanceOf(left, right){&#13;
	let proto = Object.getPrototypeOf(left);&#13;
	prototype = right.prototype;&#13;
	while(true){&#13;
		if(!proto) return false;&#13;
		if(proto === prototype) return true;&#13;
		proto = Object.getProtortpeof(proto)&#13;
	}&#13;
}&#13;
&#13;
function myInstanceOf(left, right){&#13;
	let proto = Object.getPrototypeOf(left)&#13;
	prototype = right.prototype;&#13;
	while(true){&#13;
		if(!proto) return false;&#13;
		if(proto == prototype) return true;&#13;
		proto = Object.getPrototypeOf(proto)&#13;
	}&#13;
}&#13;
```&#13;
&#13;
### 3. 手写 new 操作符&#13;
&#13;
```js&#13;
function myNew(constructor, ...args){&#13;
	if(typeof constructor !== "function") return;&#13;
	let obj = {}&#13;
	obj.prototype = Object.create(constructor.prototype)&#13;
	const res = constructor.apply(obj, args)&#13;
	if(res &amp;&amp; (typeof res !== "object" || typeof res === "function")) return res;&#13;
	return obj;&#13;
}&#13;
function Fn(obj){&#13;
	this.obj = obj;&#13;
}&#13;
let obj = myNew(Fn, "222")&#13;
console.log(obj);&#13;
&#13;
function myNew(constructor, ...args){&#13;
	if(typeof constructor !== "function") return;&#13;
	let obj = {}&#13;
	obj.prototype = Object.create(constructor.prototype)&#13;
	const res = constructor.apply(obj, args)&#13;
	if(res &amp;&amp; (typeof res !== "object" || typeof res === "function")) return res;&#13;
	return obj;	&#13;
}&#13;
function Fn(obj){&#13;
	this.obj = obj&#13;
}&#13;
let obj = myNew(Fn, "222")&#13;
console.log(obj)&#13;
&#13;
function myNew(constructor, ...args){&#13;
	if(typeof constructor !== "function") return;&#13;
	let obj = {}&#13;
	obj.prototype = Object.create(constructor.prototype)&#13;
	const res = constructor.apply(obj, args)&#13;
	if(res &amp;&amp; (typeof res !== "object" || typeof res === "function")) return res;&#13;
	return obj;&#13;
}&#13;
```&#13;
&#13;
### 4. 手写 Promise&#13;
&#13;
```js&#13;
class MyPromise{&#13;
	constructor(executor){&#13;
		this.state = "pending"&#13;
		this.value = null&#13;
		this.error = null&#13;
		this.resolve = this.resolve.bind(this);&#13;
		this.reject = this.reject.bind(this);&#13;
		executor(this.resolve, this.reject)&#13;
	}&#13;
	resolve(value){&#13;
		if(this.state === "pending"){&#13;
			this.state = "resolved"&#13;
			this.value = value;&#13;
		}&#13;
	}&#13;
	reject(error){&#13;
		if(this.state === "pending"){&#13;
			this.state = "rejected"&#13;
			this.error = error&#13;
		}&#13;
	}&#13;
&#13;
	then(onFulFilled, onRejected){&#13;
		onFulFilled = typeof onFulFilled === "function" ? onFulFilled : v =&gt; v;&#13;
		onRejected = typeof onRejected === "function" ? onRejected : r =&gt; {&#13;
			throw r&#13;
		}&#13;
		if(this.state === "resolved"){&#13;
			onFulFilled(this.value)&#13;
		}&#13;
		if(this.state === "rejected"){&#13;
			onRejcted(this.error)&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
class MyPromise{&#13;
	constructor(executor){&#13;
		this.state = "pending"&#13;
		this.value = null&#13;
		this.error = null&#13;
		this.resolve = this.resolve.bind(this)&#13;
		this.reject = this.reject.bind(this)&#13;
		executor(this.resolve, this.reject)&#13;
	}&#13;
	resolve(value){&#13;
		if(this.state === "pending"){&#13;
			this.state = "resolved"&#13;
			this.value = value&#13;
		}&#13;
	}&#13;
	reject(error){&#13;
		if(this.state === "pending"){&#13;
			this.state = "reject"&#13;
			this.error = error&#13;
		}&#13;
	}&#13;
&#13;
	then(onFulFilled, onRejected){&#13;
		onFulFilled = typeof onFulFilled === "function" ? onFulFilled : v =&gt; v;&#13;
		onRejected = typeof onRejected === "function" ? onRejected : r =&gt; {&#13;
			throw r;&#13;
		}&#13;
		if(this.state === "resolved"){&#13;
			onFulFilled(this.value)&#13;
		}&#13;
		if(this.state === "rejected"){&#13;
			onRejected(this.error)&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
class MyPromise{&#13;
	constructor(executor){&#13;
		this.state = "pending"&#13;
		this.value = null&#13;
		this.error = null&#13;
		this.resolve = this.resolve.bind(this)&#13;
		this.reject = this.reject.bind(this)&#13;
		executor(this.resolve, this.reject)&#13;
	}&#13;
	resolve(value){&#13;
		if(this.state === "pending"){&#13;
			this.state = "resolved"&#13;
			this.value = value&#13;
		}&#13;
	}&#13;
	reject(error){&#13;
		if(this.state === "pending"){&#13;
			this.state = "reject"&#13;
			this.error = error&#13;
		}&#13;
	}&#13;
	then(onFulFilled, onRejected){&#13;
		onFulFilled = typeof onFulFilled === "function" ? onFulFilled : v =&gt; v;&#13;
		onRejected = typeof OnRejected === "function" ? onRejected : r =&gt; {&#13;
			throw r;&#13;
		}&#13;
		if(this.state === "resolved"){&#13;
			onFulFilled(this.value)&#13;
		}&#13;
		if(this.state === "rejected"){&#13;
			onRejected(this.error)&#13;
		}&#13;
	}&#13;
}&#13;
```&#13;
&#13;
### 5. 手写防抖函数&#13;
&#13;
```js&#13;
function debounce(func, delay){&#13;
	let timer;&#13;
	return function(){&#13;
		const context = this;&#13;
		const args = arguments;&#13;
		clearTimer(timer);&#13;
		timer = setTimeout(()=&gt;{&#13;
			func.apply(context, args)&#13;
		}, delay)&#13;
	}&#13;
}&#13;
function handleClick(){&#13;
	//...&#13;
}&#13;
const button = document.getElementById("mybutton")&#13;
button.addListener("click", debounce(handleClick, 1000))&#13;
```&#13;
&#13;
### 6. 手写节流函数&#13;
&#13;
```js&#13;
function throttle(func, delay){&#13;
	let lastExecTime = 0;&#13;
	return function(){&#13;
		const context = this&#13;
		const args = arguments;&#13;
		let curTime = date.now()&#13;
		if(curTime - lastExecTime &gt; delay){&#13;
			func.apply(func, args)&#13;
			lastExecTime = curTime&#13;
		}&#13;
	}&#13;
}&#13;
function handleScroll(){&#13;
	console.log("scrolling...")&#13;
}&#13;
&#13;
window.addEventListener("scroll", throttle(handleScroll, 1000))&#13;
```&#13;
&#13;
### 7. 手写类型判断函数&#13;
&#13;
```js&#13;
function getType(value){&#13;
	if(value === null){&#13;
		return value + "";&#13;
	}&#13;
	if (typeof value === "object"){&#13;
		let valueClass = Object.prototype.toString.call(value);&#13;
		type = valueClass.split(" ")[1].split("");&#13;
		type.pop()&#13;
		return type.join("").toLowerCase();&#13;
	}else{&#13;
		return typeof value;&#13;
	}&#13;
}&#13;
```&#13;
&#13;
### 8. 手写 call 函数&#13;
&#13;
```js&#13;
Function.prototype.myCall = function(ctx, ...args){&#13;
	if(typeof this !== "function") return;&#13;
	ctx = ctx || window;&#13;
	const fn = Symbol()&#13;
	ctx[fn] = this&#13;
	const result = ctx[fn](...args)&#13;
	delete ctx[fn]&#13;
	return result&#13;
}&#13;
Function.prototype = function(ctx, ...args){&#13;
	if(typeof this !== "function") return;&#13;
	ctx = ctx || window;&#13;
	const fn = Symbol()&#13;
	ctx[fn] = this&#13;
	const result = ctx[fn](...args)&#13;
	delete ctx[fn]&#13;
	return result&#13;
}&#13;
&#13;
Function.prototype = function(ctx, ...args){&#13;
	if(typeof this !== "function") return;&#13;
	ctx = ctx ||  window&#13;
	const fn = Symbol()&#13;
	ctx[fn] = this&#13;
	const result = ctx[fn](...args)&#13;
	delete ctx[fn]&#13;
	return result&#13;
}&#13;
&#13;
Function.prototype = function(ctx, ...args){&#13;
	if(typeof this !== "function") return;&#13;
	ctx = ctx || window&#13;
	const fn = Symbol()&#13;
	ctx[fn] = this&#13;
	const result = ctx[fn](...args)&#13;
	delete ctx[fn]&#13;
	return result&#13;
}&#13;
```&#13;
&#13;
### 9. 手写 apply 函数&#13;
&#13;
```js&#13;
&#13;
Function.prototype.myCall = function(ctx, args){&#13;
	if(typeof this !== "function") return&#13;
	ctx = ctx || window&#13;
	const fn = Symbol&#13;
	ctx[fn] = this&#13;
	const result = ctx[fn](...args)&#13;
	delete ctx[fn]&#13;
	return result&#13;
}&#13;
```&#13;
&#13;
### 10. 手写 bind 函数&#13;
&#13;
```js&#13;
Function.prototype.myBind = function(ctx, ...args1){&#13;
	if(typeof this !== "function") return;&#13;
	const fn = this&#13;
	return function(...args2){&#13;
		const allArgs = [...args1, ...args2]&#13;
		if(new.target){&#13;
			return new fn(...allArgs)&#13;
		}else{&#13;
			return fn.apply(ctx, allArgs)&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
Function.protortpe.myBind = function(ctx, ...args1){&#13;
	if(typeof this !== "function") return;&#13;
	const fn = this&#13;
	return function(...args2){&#13;
		const allArgs = [...args1, ...args2]&#13;
		if(new.target){&#13;
			return new fn(...allArgs)&#13;
		}else{&#13;
			return fn.apply(ctx, allArgs)&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
Function.prototype.myBind = function(ctx, ...args1){&#13;
	if(typeof this !== "function") return;&#13;
	const fn = this&#13;
	return function(...args2){&#13;
		const allArgs = [...args1, ...args2]&#13;
		if(new.target){&#13;
			return new fn(...allArgs)&#13;
		}else{&#13;
			return fn.apply(ctx, allArgs)&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
Function.prototype.myBind = function(ctx, ...args1){&#13;
	if(typeof this !== "function") return;&#13;
	const fn = this;&#13;
	return function(...args2){&#13;
		const allArgs = [...args1, ...args2]&#13;
		if(new.target){&#13;
			return new fn(...allArgs)&#13;
		}else{&#13;
			return fn.apply(ctx, allArgs)&#13;
		}&#13;
	}&#13;
}&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240418Note-%20fe%20-%20handwritten%20question.html</guid><pubDate>Thu, 18 Apr 2024 09:15:52 +0000</pubDate></item><item><title>240417Note: em - app&amp;network</title><link>https://blog.chenkeyan.com/post/240417Note-%20em%20-%20app%26network.html</link><description># 1. 进程&amp;线程&#13;
## 1.1 异步IO和同步IO区别？&#13;
&#13;
如果是同步IO，当一个IO操作执行时，应用程序必须等待，直到此IO执行完。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240417Note-%20em%20-%20app%26network.html</guid><pubDate>Wed, 17 Apr 2024 04:06:12 +0000</pubDate></item><item><title>240416Note: em - driver&amp;os</title><link>https://blog.chenkeyan.com/post/240416Note-%20em%20-%20driver%26os.html</link><description># 1. 驱动开发&#13;
&#13;
## 1.1 Linux驱动程序的功能是什么？&#13;
&#13;
- 对设备初始化和释放&#13;
- 进行内核与硬件的数据交互&#13;
- 检测和处理设备出现的错误&#13;
## 1.2 内核程序申请内存使用什么函数？&#13;
&#13;
- kmalloc()&#13;
- kzallo()&#13;
- vmalloc()&#13;
&#13;
解读：&#13;
```c&#13;
void *kmalloc(size_t, size, gfp_t flags)&#13;
- 申请连续的物理内存，这对于要进行DMA的设备十分重要，但大小不能超过128KB，其中16B是被页描述符占用了&#13;
- 较常用的flag有GFP_ATOMIC，分配内存的过程是一个原子过程，GFP_KERNEL正常分配内存，GFP_DMA给DMA控制器分配内存&#13;
- 对应的内存释放函数为void kfree(const void *objp)&#13;
&#13;
void *kzalloc(size_t size, gfp_t flags);&#13;
- kzalloc()相对于kmalloc()只是额外增加了_GFP_ZERO标志，除了申请内存外，还会对申请到的内存清零&#13;
- 对应的释放函数也是kfree()&#13;
&#13;
void *vmalloc(unsigned long size);&#13;
- 申请虚拟地址连续的内存空间，但其对应的物理内存不一定连续，因此对申请的内存大小没有限制&#13;
- 对应的内存释放函数为void vfree&#13;
- 注意：vmalloc()和vfree()可以睡眠，因此不能再中断上下文调用&#13;
```&#13;
&#13;
## 1.3 内核程序中申请内存和应用程序申请内存有什么区别？&#13;
&#13;
内核中申请内存空间用的是函数kmalloc、kzalloc、vmalloc，应用程序申请内存用的是函数malloc&#13;
&#13;
- kmalloc、kzalloc直接分配连续的物理地址，虚拟也是连续的&#13;
- vmalloc分配连续的虚拟地址，但物理地址不一定连续。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240416Note-%20em%20-%20driver%26os.html</guid><pubDate>Tue, 16 Apr 2024 13:42:47 +0000</pubDate></item><item><title>240403Note: Mamba: Linear-Time Sequence Modeling with Selective State Spaces</title><link>https://blog.chenkeyan.com/post/240403Note-%20Mamba-%20Linear-Time%20Sequence%20Modeling%20with%20Selective%20State%20Spaces.html</link><description># 标题&#13;
&#13;
Mamba: Linear-Time Sequence Modeling with Selective State Spaces&#13;
&#13;
具有选择状态空间的线性时间序列建模&#13;
&#13;
背景&#13;
&#13;
发表时间：2023年12月&#13;
单位：卡内基梅隆大学&#13;
作者：Albert Gu*, Tri Dao*&#13;
![image](https://github.com/Geekiter/geekiter.github.io/assets/20443506/2048ac96-db1b-41af-a03f-fdf653e146cf)&#13;
&#13;
# Mamba架构&#13;
&#13;
Mamba是由许多层Mamba堆叠而成，作者提到Mamba架构是受到H3架构（Hungry Hungry Hippo）的启发。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240403Note-%20Mamba-%20Linear-Time%20Sequence%20Modeling%20with%20Selective%20State%20Spaces.html</guid><pubDate>Wed, 03 Apr 2024 13:28:21 +0000</pubDate></item><item><title>240328Note: em - arm</title><link>https://blog.chenkeyan.com/post/240328Note-%20em%20-%20arm.html</link><description># 1.ARM处理器与中断&#13;
&#13;
## 1.1 CPU的内部结构？&#13;
CPU的内部结构大致可以分为？&#13;
- 控制单元（指令寄存器、指令译码器、操作控制器）&#13;
- 运算单元（算数逻辑单元）&#13;
- 存储单元（专用寄存器和通用寄存器）&#13;
- 时钟&#13;
&#13;
## 1.2 CPU跟内存、虚拟内存、硬盘的关系&#13;
- CPU要调用的程序和数据来自硬盘，但是CPU又不能直接读写硬盘上的系统、程序和数据，所以必须先将硬盘的内容存储在内存中，才能被CPU读写&#13;
- 内存是一个中转站，对计算机的运行速度有较大的影响&#13;
- 当系统需要的内存空间大于实际的物理内存空间时，就需要用到虚拟内存。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240328Note-%20em%20-%20arm.html</guid><pubDate>Thu, 28 Mar 2024 09:06:48 +0000</pubDate></item><item><title>240328Note: em - c&amp;data structure</title><link>https://blog.chenkeyan.com/post/240328Note-%20em%20-%20c%26data%20structure.html</link><description># 1.预处理&amp;关键字（22道）&#13;
## 1.1宏定义是在编译的哪个阶段被处理的？&#13;
&#13;
宏定义是在预编译处理阶段被处理的&#13;
&#13;
编译预处理：头文件包含：宏替换、条件编译、去除注释、添加行号&#13;
&#13;
## 1.2写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240328Note-%20em%20-%20c%26data%20structure.html</guid><pubDate>Thu, 28 Mar 2024 03:56:13 +0000</pubDate></item><item><title>240327Note: DSCNet: Dynamic Snake Convolution based on Topological Geometric Constraints for Tubular Structure Segmentation</title><link>https://blog.chenkeyan.com/post/240327Note-%20DSCNet-%20Dynamic%20Snake%20Convolution%20based%20on%20Topological%20Geometric%20Constraints%20for%20Tubular%20Structure%20Segmentation.html</link><description># Background&#13;
&#13;
- 会议：ICCV 2023&#13;
- 单位：东南大学&#13;
- 作者：Yaolei Qi&#13;
&#13;
# Contribute&#13;
- 动态蛇形卷积，自适应关注细长曲折的局部特征，在2D和3D数据集上对管状结构的精确分割&#13;
- 多视角特征融合策略，以补充对关键特征的多方面关注&#13;
- 基于点集相似性的持久同调的拓扑连续性约束损失函数，更好的约束了分割的连续性&#13;
&#13;
# Method&#13;
&#13;
## DSCNet&#13;
&#13;
![image](https://github.com/Geekiter/geekiter.github.io/assets/20443506/75625a9b-6698-4a4e-81f7-6a9e0b25dbfa)&#13;
&#13;
## 动态蛇形卷积&#13;
&#13;
![image](https://github.com/Geekiter/geekiter.github.io/assets/20443506/bb506f29-9b53-40a0-aaa1-5845a4f29251)&#13;
动态蛇形卷积DSConv用于提取管状结构的局部特征，卷积核的灵活性通过引入变形偏移来增强，采用迭代策略来确保感知范围的连续性。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240327Note-%20DSCNet-%20Dynamic%20Snake%20Convolution%20based%20on%20Topological%20Geometric%20Constraints%20for%20Tubular%20Structure%20Segmentation.html</guid><pubDate>Wed, 27 Mar 2024 08:49:08 +0000</pubDate></item><item><title>240325Note: fe - network</title><link>https://blog.chenkeyan.com/post/240325Note-%20fe%20-%20network.html</link><description>## 1.GET和POST的请求的区别&#13;
&#13;
&#13;
| 特性   | GET            | POST      |&#13;
| ---- | -------------- | --------- |&#13;
| 应用场景 | 一般不会对服务器资源产生影响 | 会产生影响     |&#13;
| 缓存   | 会              | 不会        |&#13;
| 报文格式 | 空              | 实体部分为请求数据 |&#13;
| 安全性  | 请求参数在url中，不太安全 | 相对安全      |&#13;
| 请求长度 | 受url长度限制       | 不受        |&#13;
| 请求类型 | 字符串            | 更多类型的数据   |&#13;
## 2.POST和PUT请求的区别&#13;
&#13;
put一般是更新数据，post一般是创建数据&#13;
&#13;
## 3.常见的HTTP请求头和响应头&#13;
&#13;
- HTTP Request Header &#13;
	- Accept：浏览器能够处理的内容类型&#13;
	- Accept-Encoding: 浏览器能够处理的压缩编码&#13;
	- Accept-Language：浏览器当前设置的语言&#13;
	- Connection：浏览器与服务器之间的连接类型&#13;
	- Cookie：当前页面设置的任何Cookie&#13;
	- Host：发送请求的页面所在域&#13;
	- Referer：发出请求的页面的URL&#13;
	- User-Agent：浏览器的用户代理字符串&#13;
- HTTP Response Header&#13;
	- Date：表示消息发送的时间，时间的描述格式由rfc822定义&#13;
	- Server：服务器名称&#13;
	- Connection：浏览器与服务器之间的连接类型&#13;
	- Cache-Control：控制HTTP缓存&#13;
	- content-type：表示后面的温度属于什么MIME类型&#13;
		- application/x-www-form-urlencoded：浏览器的元素form表单，default&#13;
		- multipart/form-data&#13;
		- application/json：服务器消息主体是序列化猴的JSON字符串&#13;
		- text/xml：该方式主要用来提交XML格式的数据&#13;
&#13;
## 4.HTTP状态码304是多好还是少好&#13;
&#13;
304是客户端有缓存情况下服务器的一种响应&#13;
&#13;
适中&#13;
&#13;
太多：&#13;
&#13;
- 网页快照停止&#13;
- 收录减少&#13;
&#13;
&#13;
## 5.常见的HTTP请求方法&#13;
&#13;
- GET获取数据&#13;
- POST提交数据&#13;
- PUT上传更新数据&#13;
- DELETE删除数据&#13;
- HEAD获取报文首部，不返回主体&#13;
- OPTIONS询问支持，一般用来跨域请求&#13;
- CONNECT：要求与代理服务器建立隧道，使用隧道用于TCP通信&#13;
- TRACE，用于测试或者诊断&#13;
## 6. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？&#13;
&#13;
- 连接，1.0默认非持久连接，1.1持久连接&#13;
- 资源请求，1.0存在宽带浪费，比如客户端只需要对象的一部分，服务器却给了整个对象。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240325Note-%20fe%20-%20network.html</guid><pubDate>Mon, 25 Mar 2024 08:05:06 +0000</pubDate></item><item><title>240324Note: fe - browser</title><link>https://blog.chenkeyan.com/post/240324Note-%20fe%20-%20browser.html</link><description>## 1.什么是 XSS 攻击？&#13;
&#13;
xss是跨站脚本攻击，是一种代码注入工具。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240324Note-%20fe%20-%20browser.html</guid><pubDate>Sun, 24 Mar 2024 03:27:17 +0000</pubDate></item><item><title>240319Note: fe - engineer</title><link>https://blog.chenkeyan.com/post/240319Note-%20fe%20-%20engineer.html</link><description>## 1.如何⽤ webpack 来优化前端性能？&#13;
&#13;
- 代码分割&#13;
- 压缩代码&#13;
- Tree Shaking&#13;
- 图片优化&#13;
- 使用CDN&#13;
- 缓存优化&#13;
- 懒加载和预加载&#13;
- 使用Webpack插件，使用优化类的webpack插件，如minicssextractplugin提取css，htmlwebpackplugin生成html，bundleanalyzerplugin分析打包文件等&#13;
&#13;
- 代码分割，将代码拆分微多个小块，按需加载。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240319Note-%20fe%20-%20engineer.html</guid><pubDate>Tue, 19 Mar 2024 10:02:13 +0000</pubDate></item><item><title>240318Note: fe - code output</title><link>https://blog.chenkeyan.com/post/240318Note-%20fe%20-%20code%20output.html</link><description>## 一、异步&amp;事件循环&#13;
&#13;
1.&#13;
```js&#13;
const promise = new Promise((resolve, reject) =&gt; {&#13;
  console.log(1);&#13;
  console.log(2);&#13;
});&#13;
promise.then(() =&gt; {&#13;
  console.log(3);&#13;
});&#13;
console.log(4);&#13;
&#13;
%% 输出&#13;
&#13;
1&#13;
2&#13;
4 %%&#13;
&#13;
```&#13;
&#13;
因为没有写resolve，所以没有输出3&#13;
&#13;
2.&#13;
```js&#13;
const promise1 = new Promise((resolve, reject) =&gt; {&#13;
  console.log('promise1')&#13;
  resolve('resolve1')&#13;
})&#13;
const promise2 = promise1.then(res =&gt; {&#13;
  console.log(res)&#13;
})&#13;
console.log('1', promise1);&#13;
console.log('2', promise2);&#13;
```&#13;
&#13;
```&#13;
promise1&#13;
1 Promise{&lt;resolved&gt;: resolve1}&#13;
2 Promise{&lt;pending&gt;}&#13;
resolve1&#13;
```&#13;
&#13;
3.&#13;
```js&#13;
const promise = new Promise((resolve, reject) =&gt; {&#13;
  console.log(1);&#13;
  setTimeout(() =&gt; {&#13;
    console.log("timerStart");&#13;
    resolve("success");&#13;
    console.log("timerEnd");&#13;
  }, 0);&#13;
  console.log(2);&#13;
});&#13;
promise.then((res) =&gt; {&#13;
  console.log(res);&#13;
});&#13;
console.log(4);&#13;
```&#13;
&#13;
```&#13;
1&#13;
2&#13;
4&#13;
timeStart&#13;
timerEnd&#13;
success&#13;
```&#13;
&#13;
4.&#13;
&#13;
```js&#13;
Promise.resolve().then(() =&gt; {&#13;
  console.log('promise1');&#13;
  const timer2 = setTimeout(() =&gt; {&#13;
    console.log('timer2')&#13;
  }, 0)&#13;
});&#13;
const timer1 = setTimeout(() =&gt; {&#13;
  console.log('timer1')&#13;
  Promise.resolve().then(() =&gt; {&#13;
    console.log('promise2')&#13;
  })&#13;
}, 0)&#13;
console.log('start');&#13;
/**&#13;
start&#13;
promise1&#13;
timer1&#13;
timer2&#13;
promise2&#13;
&#13;
微1&#13;
promise1&#13;
&#13;
宏2&#13;
timer1&#13;
&#13;
宏1&#13;
start&#13;
微1&#13;
promise1&#13;
宏3 timer2&#13;
宏1 timer1&#13;
微3 promise2&#13;
&#13;
*/&#13;
```&#13;
&#13;
5.&#13;
```js&#13;
const promise = new Promise((resolve, reject) =&gt; {&#13;
    resolve('success1');&#13;
    reject('error');&#13;
    resolve('success2');&#13;
});&#13;
promise.then((res) =&gt; {&#13;
    console.log('then:', res);&#13;
}).catch((err) =&gt; {&#13;
    console.log('catch:', err);&#13;
})&#13;
then: success1&#13;
```&#13;
&#13;
6.&#13;
```js&#13;
Promise.resolve(1)&#13;
  .then(2)&#13;
  .then(Promise.resolve(3))&#13;
  .then(console.log)&#13;
```&#13;
&#13;
```js&#13;
1&#13;
Promise {&lt;fulfilled&gt;: undefined}&#13;
```&#13;
&#13;
7.&#13;
```js&#13;
const promise1 = new Promise((resolve, reject) =&gt; {&#13;
  setTimeout(() =&gt; {&#13;
    resolve('success')&#13;
  }, 1000)&#13;
})&#13;
const promise2 = promise1.then(() =&gt; {&#13;
  throw new Error('error!!!')&#13;
})&#13;
console.log('promise1', promise1)&#13;
console.log('promise2', promise2)&#13;
setTimeout(() =&gt; {&#13;
  console.log('promise1', promise1)&#13;
  console.log('promise2', promise2)&#13;
}, 2000)&#13;
```&#13;
&#13;
```js&#13;
promise1 Promise {&lt;pending&gt;}&#13;
promise2 Promise {&lt;pending&gt;}&#13;
&#13;
Uncaught (in promise) Error: error!!!&#13;
promise1 Promise {&lt;fulfilled&gt;: "success"}&#13;
promise2 Promise {&lt;rejected&gt;: Error: error!!}&#13;
```&#13;
&#13;
8.&#13;
```js&#13;
Promise.resolve(1)&#13;
  .then(res =&gt; {&#13;
    console.log(res);&#13;
    return 2;&#13;
  })&#13;
  .catch(err =&gt; {&#13;
    return 3;&#13;
  })&#13;
  .then(res =&gt; {&#13;
    console.log(res);&#13;
  });&#13;
&#13;
1&#13;
2&#13;
```&#13;
&#13;
9.&#13;
```js&#13;
Promise.resolve().then(() =&gt; {&#13;
  return new Error('error!!!')&#13;
}).then(res =&gt; {&#13;
  console.log("then: ", res)&#13;
}).catch(err =&gt; {&#13;
  console.log("catch: ", err)&#13;
})&#13;
```&#13;
&#13;
```js&#13;
"then: " "Error: error!!!"&#13;
```&#13;
&#13;
10.&#13;
```js&#13;
const promise = Promise.resolve().then(() =&gt; {&#13;
  return promise;&#13;
})&#13;
promise.catch(console.err)&#13;
```&#13;
&#13;
```&#13;
Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&#13;
```&#13;
&#13;
`.then` 或 `.catch` 返回的值不能是 promise 本身，否则会造成死循环。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240318Note-%20fe%20-%20code%20output.html</guid><pubDate>Mon, 18 Mar 2024 11:53:15 +0000</pubDate></item><item><title>240313Note: fe - js</title><link>https://blog.chenkeyan.com/post/240313Note-%20fe%20-%20js.html</link><description>## 1、JavaScript有哪些数据类型，它们的区别？&#13;
&#13;
- Undefined&#13;
- Null&#13;
- Boolean&#13;
- Number&#13;
- String&#13;
- Object&#13;
- ES6&#13;
	- Symbol，创建后独一无二不可变的数据类型，为了解决可能出现的全局变量重复&#13;
	- BigInt，安全的存储和操作大整数&#13;
&#13;
可以分为堆和栈&#13;
- 栈&#13;
	- undefined、null、boolean、number、string&#13;
- 堆&#13;
	- 对象，数组和函数&#13;
&#13;
&#13;
&#13;
## 2、数据类型检测的方式有哪些&#13;
&#13;
- typeof&#13;
- instanceof&#13;
```js&#13;
2 instanceof Number&#13;
true instanceof Boolean&#13;
```&#13;
- constructor&#13;
```js&#13;
(2).constructor === Number&#13;
(true).constructor === Boolean&#13;
```&#13;
&#13;
- Object.prototype.toString.call()&#13;
```js&#13;
var a = Object.prototype.toString;&#13;
&#13;
console.log(a.call(2));&#13;
```&#13;
&#13;
&#13;
## 3、 判断数组的方式有哪些&#13;
&#13;
```js&#13;
Object.prototype.toString.call(obj).slice(8, -1) === "Array"&#13;
&#13;
Array.isArray(obj)&#13;
&#13;
obj.__proto__ === Array.prototype&#13;
&#13;
obj instanceof Array&#13;
&#13;
Array.prototype.isPrototypeOf(obj)&#13;
```&#13;
## 4、 null和undefined区别&#13;
&#13;
- undefine代表未定义，null代表空对象。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240313Note-%20fe%20-%20js.html</guid><pubDate>Wed, 13 Mar 2024 02:12:33 +0000</pubDate></item><item><title>240307Note: fe - Vue.js</title><link>https://blog.chenkeyan.com/post/240307Note-%20fe%20-%20Vue.js.html</link><description>## 1、vue开发中常用的指令有哪些？&#13;
- v-if，v-else, v-else-if, v-show&#13;
- v-for&#13;
- v-on&#13;
- v-model&#13;
- v-bind&#13;
- v-html&#13;
- v-text&#13;
## 2、vuediff算法的原理&#13;
首先比较新旧节点的标签名，&#13;
- 如果不同，直接替换成新的节点。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240307Note-%20fe%20-%20Vue.js.html</guid><pubDate>Thu, 07 Mar 2024 13:41:05 +0000</pubDate></item><item><title>240305Note: fe - HTML&amp;CSS</title><link>https://blog.chenkeyan.com/post/240305Note-%20fe%20-%20HTML%26CSS.html</link><description>&#13;
## HTML+CSS&#13;
&#13;
10/37&#13;
&#13;
## 1.说一下 web worker&#13;
&#13;
在HTML页面中，如果在执行脚本时，页面的状态是不可响应的，知道脚本执行完成后，页面才变得可以响应。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240305Note-%20fe%20-%20HTML%26CSS.html</guid><pubDate>Tue, 05 Mar 2024 11:59:52 +0000</pubDate></item><item><title>240305Note: fe - React</title><link>https://blog.chenkeyan.com/post/240305Note-%20fe%20-%20React.html</link><description>&#13;
&#13;
## React&#13;
&#13;
### 一、组件基础&#13;
#### 1. React 事件机制&#13;
&#13;
```js&#13;
&lt;div&#13;
	onClick={this.handleClick.bind(this)}&#13;
&gt;&#13;
	点我&#13;
&lt;/div&gt;&#13;
```&#13;
&#13;
react并不是将click事件绑定到div真实的dom上，而是在document处监听了所有的事件。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240305Note-%20fe%20-%20React.html</guid><pubDate>Tue, 05 Mar 2024 03:54:23 +0000</pubDate></item><item><title>240304Note: 竹云 前端</title><link>https://blog.chenkeyan.com/post/240304Note-%20-zhu-yun-%20-qian-duan.html</link><description>5.跨域问题&#13;
- 同源策略，限制一个源origin的文档与脚本与另一个源进行交互，如果协议、域名或者端口有一个不同就会视为不同的源。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240304Note-%20-zhu-yun-%20-qian-duan.html</guid><pubDate>Mon, 04 Mar 2024 08:43:25 +0000</pubDate></item><item><title>240304Note: 博世-前端-一面</title><link>https://blog.chenkeyan.com/post/240304Note-%20-bo-shi---qian-duan---yi-mian.html</link><description>&#13;
1、自我介绍  &#13;
2、介绍下项目&#13;
  &#13;
1、你项目都是vue3做的吗  &#13;
2、怎么用vuex不用pinia&#13;
vuex是官方库&#13;
4、vite有了解吗（不知）  &#13;
5、jwt后端签发的吗 &#13;
是&#13;
6、说下闭包&#13;
允许一个函数访问并操作函数外部变量，闭包发生在一个函数内部创建另一个函数时&#13;
```js&#13;
function createCounter(){&#13;
	let count = 0;&#13;
	return function(){&#13;
		count++;&#13;
		return count;&#13;
	}&#13;
}&#13;
&#13;
const counter = createCounter();&#13;
console.log(counter()); //1&#13;
console.log(counter()); //2&#13;
```&#13;
7、你们项目管理用git了吗  &#13;
8、osi七层模型？看我不知道又换了个说法，url从点击到显示过程中用到了哪些协议  &#13;
- 应用层&#13;
- 表示层&#13;
- 会话层&#13;
- 传输层&#13;
- 网络层&#13;
- 数据链路层&#13;
- 物理层&#13;
9、响应式原理说说（感觉很高频，每次面试几乎都有，我从vue2和vue3的区别扯到ref和reactive）  &#13;
Vue.js的响应式系统基于JavaScript对象属性访问器，getter和setter，以及现代浏览器的proxy对象，&#13;
&#13;
技术问题就到此结束了，人家跟我说如果来了有完善的培养体系 。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240304Note-%20-bo-shi---qian-duan---yi-mian.html</guid><pubDate>Mon, 04 Mar 2024 07:11:54 +0000</pubDate></item><item><title>240303Note: 金山云 前端 一面</title><link>https://blog.chenkeyan.com/post/240303Note-%20-jin-shan-yun-%20-qian-duan-%20-yi-mian.html</link><description>1.flex布局实现垂直置顶，靠右对齐  &#13;
&#13;
- 创建一个容器&#13;
- 设置flex方向&#13;
- 垂直对齐&#13;
```css&#13;
.container{&#13;
	display: flex;&#13;
	align-items: flex-start; &#13;
	justify-content: flex-end;&#13;
}&#13;
```&#13;
- 水平对齐&#13;
&#13;
2.align-content和align-self的区别  &#13;
- align-content控制的是多行或多列的整体对齐方式，align-self控制的是容器内单个项目的对齐方式&#13;
3.箭头函数和普通函数的区别 &#13;
```js&#13;
const square = function(x){&#13;
	return x * x;&#13;
}&#13;
&#13;
const squareArrow = x =&gt; x *x;&#13;
```&#13;
- 语法简洁&#13;
	- 箭头函数简洁&#13;
	- this的绑定，箭头函数不绑定自己的this，捕获上下文的this。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240303Note-%20-jin-shan-yun-%20-qian-duan-%20-yi-mian.html</guid><pubDate>Sun, 03 Mar 2024 04:49:32 +0000</pubDate></item><item><title>240227Note: 数字马力-前端-一面</title><link>https://blog.chenkeyan.com/post/240227Note-%20-shu-zi-ma-li---qian-duan---yi-mian.html</link><description># 数字马力 前端一面 时间50分钟&#13;
&#13;
1.项目介绍，亮点  &#13;
&#13;
&#13;
2.路由怎么实现的，react-router cacherouter是干嘛的，hash router和history router的区别  &#13;
&#13;
1. 安装react-router-dom&#13;
2. 创建路由组件&#13;
3. 使用BrowserRouter或HashRouter包裹应用&#13;
4. 在组件中使用Link进行导航&#13;
&#13;
其中Browser或HashRouter包裹应用&#13;
```javascript&#13;
import {BrowserRouter as Router, Route, Switch} from "react-router-dom";&#13;
&#13;
function App(){&#13;
	return (&#13;
		&lt;Router&gt;&#13;
			&lt;Switch&gt;&#13;
				&lt;Route path="/path" component={Home} /&gt;&#13;
				&lt;Route path="/about" component={About} /&gt;&#13;
			&lt;/Switch&gt;&#13;
		&lt;/Router&gt;&#13;
	)&#13;
}&#13;
```&#13;
&#13;
使用Link&#13;
```js&#13;
import {Link} from "react-router-dom";&#13;
function Navigation(){&#13;
	return (&#13;
		&lt;nav&gt;&#13;
			&lt;ul&gt;&#13;
				&lt;li&gt;&lt;Link to="/home"&gt;Home&lt;/Link&gt;&lt;/li&gt;&#13;
				&lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;&#13;
			&lt;/ul&gt;&#13;
		&lt;/nav&gt;&#13;
	)&#13;
}&#13;
```&#13;
&#13;
3.useffect怎么实现副作用的，怎么在卸载前取消订阅  &#13;
&#13;
```js&#13;
import React, {useState, useEffect} from "react";&#13;
&#13;
function ExampleComponent(){&#13;
	const [data, setData] = useState(null);&#13;
	useEffect(()=&gt;{&#13;
		const fetchDate = async () =&gt; {&#13;
			const result = await fetch("http://api.com");&#13;
			const jsonData = await result.json();&#13;
			setData(jsonData);&#13;
		}&#13;
&#13;
		return ()={&#13;
		//返回的清理函数在组件卸载时执行，用于取消订阅或执行其他清理操作。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240227Note-%20-shu-zi-ma-li---qian-duan---yi-mian.html</guid><pubDate>Tue, 27 Feb 2024 13:44:50 +0000</pubDate></item><item><title>240226Note：阿里-前端</title><link>https://blog.chenkeyan.com/post/240226Note%EF%BC%9A-a-li---qian-duan.html</link><description>1. 项目难点&#13;
&#13;
Web移动端调取摄像头，录制内容实时渲染在界面上，可以拖拽和隐藏，&#13;
&#13;
- 调取摄像头：video标签，js里用navigator.mediaDevices.getUserMedia({video: true})，video.srbObject = stream;&#13;
- 拖拽&#13;
	- 添加mousemove和mouseup事件，获取clientX、offsetLeft和clientY和offsetTop&#13;
	- 隐藏用display属性&#13;
- 自定义视频播放器事件，完成课前人脸识别打卡，课中暂停随堂检测，通过Websocket实时记录时长&#13;
	- 自定义视频播放器事件：包括paly,ended,pause&#13;
	- 通过Websocket实时记录时长，通过new 一个Websocket对象&#13;
- 自定义axios网络请求拦截，完成token注入和刷新，权限验证&#13;
	- 通过interceptors.request.use和interceptors.response.use&#13;
&#13;
CSS&#13;
&#13;
1. CSS 盒模型&#13;
2. 定位 Position&#13;
3. 水平/垂直居中&#13;
	1. ### 水平居中&#13;
		1. #### 行内元素水平居中（文本、内联元素等）&#13;
			1. text-align: center;&#13;
		2. ####  块级元素水平居中（有固定宽度）&#13;
			1. width: 300px; /* 设置容器宽度 */ margin: 0 auto; /* 将左右外边距设为 auto */&#13;
		3. ####  Flexbox 水平居中&#13;
			1. display: flex; justify-content: center;&#13;
	2. ### 垂直居中&#13;
		1. ####  单行文本垂直居中&#13;
			1. height: 100px; /* 设置容器高度 */ line-height: 100px; /* 与容器高度相同 */&#13;
		2. #### 多行文本垂直居中&#13;
			1. 可以使用 Flexbox 或者 CSS Grid 来实现垂直居中。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240226Note%EF%BC%9A-a-li---qian-duan.html</guid><pubDate>Mon, 26 Feb 2024 13:53:17 +0000</pubDate></item><item><title>240213Note: 喜马拉雅Java一面</title><link>https://blog.chenkeyan.com/post/240213Note-%20-xi-ma-la-ya-Java-yi-mian.html</link><description># JDK17有啥新特性&#13;
&#13;
1. 封闭类，sealed classes，限制那些类可以拓展和实现某个类&#13;
2. switch语句的模式匹配&#13;
3. jvm启动时处理并行线程&#13;
&#13;
# 如何使用Git进行版本控制&#13;
初始化：git init&#13;
添加到暂存区：git add&#13;
提交更改：git commit&#13;
提交到远程仓库：git push&#13;
&#13;
# 为什么用RabbitMQ&#13;
&#13;
RabbitMQ是一个流行的开源信息代理软件，被用于构建分布式系统和大规模信息传递。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240213Note-%20-xi-ma-la-ya-Java-yi-mian.html</guid><pubDate>Tue, 13 Feb 2024 13:57:20 +0000</pubDate></item><item><title>240207笔记：快手Java一面</title><link>https://blog.chenkeyan.com/post/240207-bi-ji-%EF%BC%9A-kuai-shou-Java-yi-mian.html</link><description>&#13;
&#13;
# MySQL最左匹配&#13;
&#13;
在MySQL中，"最左匹配"是指在多列索引中，MySQL只能利用索引的最左边的部分列进行索引查找。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240207-bi-ji-%EF%BC%9A-kuai-shou-Java-yi-mian.html</guid><pubDate>Wed, 07 Feb 2024 13:23:46 +0000</pubDate></item><item><title>240203Note: Combine two sorted arrays</title><link>https://blog.chenkeyan.com/post/240203Note-%20Combine%20two%20sorted%20arrays.html</link><description>思路：&#13;
虽然也是在双指针，但是这一题是从后面开始遍历的。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/240203Note-%20Combine%20two%20sorted%20arrays.html</guid><pubDate>Sat, 03 Feb 2024 06:32:04 +0000</pubDate></item><item><title>231206笔记：next-auth</title><link>https://blog.chenkeyan.com/post/231206-bi-ji-%EF%BC%9Anext-auth.html</link><description>Q1: 如何在webstorm中调试next.js，包括前后端代码&#13;
&#13;
- 后端debug&#13;
&#13;
1. debug模式启动dev服务器&#13;
&#13;
- 前端debug&#13;
&#13;
1. 配置JavaScript Debug，输入前端url地址&#13;
&#13;
Q2：postgresql docker 的管理员账号&#13;
&#13;
账号一般是：postgresql&#13;
密码在配置docker的POSTGRES_PASSWORD中&#13;
&#13;
Q3：windows抓包软件&#13;
&#13;
Reqable&#13;
&#13;
Q4: next-auth本地配置github，登陆之后404&#13;
&#13;
本地地址github无法回调，只能部署&#13;
&#13;
Q5：next.js如何获取request ip&#13;
&#13;
从request.headers['x-forwarded-for']中获取&#13;
&#13;
Q6: ip获取到的是::1&#13;
&#13;
是ipv6的本地地址&#13;
&#13;
Q7：prisma中用enum定义字段， 创建的如何写？&#13;
&#13;
举例，如果定义了一个enum类型的字段，如下：&#13;
```js&#13;
enum System{&#13;
    WINDOWS&#13;
    LINUX&#13;
    MAC&#13;
}&#13;
```&#13;
&#13;
那么在创建的时候，需要写成：&#13;
```js&#13;
await prisma.system.create({&#13;
    data:{&#13;
        name: 'WINDOWS' as System&#13;
    }&#13;
})&#13;
```&#13;
&#13;
Q8: nextauth有那些callback？&#13;
&#13;
session、jwt、redirect、signIn&#13;
&#13;
session没登陆成功前会调用，然后登陆成功之后手动调用才会触发&#13;
&#13;
jwt只有在使用json web token的时候才会调用&#13;
&#13;
redirect是在调整地址的时候调用，一般没什么用&#13;
&#13;
signIn是在登陆成功前调用&#13;
&#13;
Q9: next.js的server component如何用点击事件？&#13;
&#13;
点击封装成一个组件，如何导入。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/231206-bi-ji-%EF%BC%9Anext-auth.html</guid><pubDate>Wed, 06 Dec 2023 02:30:31 +0000</pubDate></item><item><title>231101笔记：padavan hiboy的clash失效事件</title><link>https://blog.chenkeyan.com/post/231101-bi-ji-%EF%BC%9Apadavan%20hiboy-de-clash-shi-xiao-shi-jian.html</link><description>当生活节奏慢下来，我再也无法忍受如此糟糕的国际漫游网络，于是我决定对路由器进行一些调整。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/231101-bi-ji-%EF%BC%9Apadavan%20hiboy-de-clash-shi-xiao-shi-jian.html</guid><pubDate>Tue, 05 Dec 2023 13:15:32 +0000</pubDate></item><item><title>231125笔记：Spring基础构建</title><link>https://blog.chenkeyan.com/post/231125-bi-ji-%EF%BC%9ASpring-ji-chu-gou-jian.html</link><description>Q1：如何创建postgresql和mysql的Docker容器&#13;
&#13;
- 拉取镜像&#13;
&#13;
以mysql为例&#13;
&#13;
```shell&#13;
docker pull mysql&#13;
```&#13;
&#13;
- 创建并启动容器&#13;
&#13;
```shell&#13;
docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql&#13;
```&#13;
&#13;
注意：&#13;
&#13;
- 配置e，这是镜像需要的一些参数&#13;
- 配置p，将容器的端口映射到本地，不然只能用容器的ip去访问&#13;
&#13;
Q2：maven引入mysql-connector-java报错Cannot find class:com.mysql.jdbc.Drive&#13;
&#13;
版本问题，换个高版本的。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/231125-bi-ji-%EF%BC%9ASpring-ji-chu-gou-jian.html</guid><pubDate>Tue, 05 Dec 2023 13:12:47 +0000</pubDate></item><item><title>230908笔记：React表单双向绑定</title><link>https://blog.chenkeyan.com/post/230908-bi-ji-%EF%BC%9AReact-biao-dan-shuang-xiang-bang-ding.html</link><description>当使用 React 来创建表单时，我们可以像 Vue.js 一样实现双向绑定。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/230908-bi-ji-%EF%BC%9AReact-biao-dan-shuang-xiang-bang-ding.html</guid><pubDate>Tue, 05 Dec 2023 13:11:28 +0000</pubDate></item><item><title>230907笔记：Django Docker</title><link>https://blog.chenkeyan.com/post/230907-bi-ji-%EF%BC%9ADjango%20Docker.html</link><description>记录一下吧，遇到了一个很奇怪的问题。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/230907-bi-ji-%EF%BC%9ADjango%20Docker.html</guid><pubDate>Tue, 05 Dec 2023 13:11:02 +0000</pubDate></item><item><title>230906笔记：WordPress Docker部署</title><link>https://blog.chenkeyan.com/post/230906-bi-ji-%EF%BC%9AWordPress%20Docker-bu-shu.html</link><description>最近需要部署一个wordpress到服务器上，因为我觉得php安装不像python那样熟悉和方便，另外我感觉好像会自动占用80端口，就不是很想在原生系统上安装php，准备用一个docker跑wordpress。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/230906-bi-ji-%EF%BC%9AWordPress%20Docker-bu-shu.html</guid><pubDate>Tue, 05 Dec 2023 13:10:37 +0000</pubDate></item><item><title>230904笔记: BoxInst</title><link>https://blog.chenkeyan.com/post/230904-bi-ji--%20BoxInst.html</link><description># BoxInst官方代码&#13;
https://github.com/aim-uofa/AdelaiDet&#13;
&#13;
# Q1：安装官方的包时报错THC/THC.h 相关头文件找不到&#13;
原因PyTorch新版本移除了相关的实现，解决办法，去其它仓库找以适配好的代码。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/230904-bi-ji--%20BoxInst.html</guid><pubDate>Tue, 05 Dec 2023 13:09:36 +0000</pubDate></item><item><title>230821笔记: html table</title><link>https://blog.chenkeyan.com/post/230821-bi-ji--%20html%20table.html</link><description>## 1. Table Text Alignment&#13;
&#13;
```scss&#13;
th {&#13;
  text-align: center;&#13;
  vertical-align: middle;&#13;
}&#13;
```&#13;
&#13;
The `vertical-align` property sets the vertical alignment of the content in `&lt;th&gt;` or `&lt;td&gt;` (such as top, bottom, or middle).&#13;
&#13;
By default, the vertical alignment of content in a table is `middle`.&#13;
&#13;
## 2. **box-sizing**&#13;
&#13;
When an element is set to `box-sizing: border-box;`, its padding and border no longer increase its width.&#13;
&#13;
## 3. How to Hide Table Borders&#13;
&#13;
Set `border-top`, `border-left`, `border-bottom`, and `border-right` of `th` and `td` to `none`.&#13;
&#13;
## 4. CSS Calculation&#13;
&#13;
`calc()`&#13;
&#13;
## 5. Horizontal Scrolling for Tables&#13;
&#13;
```scss&#13;
.container1{&#13;
	width: 1000px;&#13;
}&#13;
&#13;
.container2{&#13;
  position: relative;&#13;
  overflow: auto;&#13;
  white-space: nowrap;&#13;
}&#13;
```&#13;
&#13;
```html&#13;
&lt;div class="container1"&gt;&#13;
	&lt;div class="container2"&gt;&#13;
			&lt;table&gt;&#13;
				&lt;tbody&gt;...&lt;/tbody&gt;&#13;
			&lt;/table&gt;&#13;
	&lt;/div&gt;&#13;
&lt;/div&gt;&#13;
```&#13;
&#13;
## 6. Frozen Columns in Tables&#13;
&#13;
```scss&#13;
.sticky-col {&#13;
  position: sticky;&#13;
	left: 0;&#13;
}&#13;
```&#13;
&#13;
## 7. Multi-Row and Multi-Column Table Headers&#13;
&#13;
```scss&#13;
&lt;th rowSpan={1} colSpan={1} &gt;&#13;
...&#13;
&lt;/th&gt;&#13;
```&#13;
&#13;
Use the `row-span` and `col-span` attributes.&#13;
&#13;
## 8. Mixing Multi-Row and Multi-Column Table Headers&#13;
&#13;
```scss&#13;
&lt;thead&gt;&#13;
	&lt;tr&gt;&#13;
		&lt;th rowSpan={1} colSpan={1} &gt;&#13;
		...&#13;
		&lt;/th&gt;&#13;
	&lt;/tr&gt;&#13;
	&lt;tr&gt;&#13;
	&lt;th rowSpan={1} colSpan={1} &gt;&#13;
	...&#13;
	&lt;/th&gt;&#13;
	&lt;/tr&gt;&#13;
&lt;/thead&gt;&#13;
```&#13;
&#13;
Calculate the positions of rows and columns that span multiple cells in advance, and the second row of headers will automatically appear in the reserved space.&#13;
&#13;
## 9. Fixed Width for Table Content&#13;
&#13;
```scss&#13;
&lt;th&gt;&#13;
	&lt;div style="widh: 220px"&gt;...&lt;/div&gt;&#13;
&lt;/th&gt;&#13;
```&#13;
&#13;
Nest a `&lt;div&gt;` element to achieve a fixed width.&#13;
。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/230821-bi-ji--%20html%20table.html</guid><pubDate>Tue, 05 Dec 2023 13:09:04 +0000</pubDate></item><item><title>230820笔记: About pnpm</title><link>https://blog.chenkeyan.com/post/230820-bi-ji--%20About%20pnpm.html</link><description>pnpm&#13;
- Official website&#13;
    - https://pnpm.io/&#13;
- Advantages&#13;
    - Fast&#13;
    - Efficient&#13;
        - Files in node_modules are copied or linked from a specific content-addressable storage repository.&#13;
    - Supports monorepos&#13;
        - Monorepo means that all the code of all projects is maintained in a single code version repository.&#13;
        - pnpm has built-in support for multiple packages in a single repository.&#13;
![image](https://github.com/Geekiter/blog-issue/assets/20443506/5b744a6a-551f-47df-a073-da9bcb50bff6)&#13;
&#13;
- Differences from npm and yarn&#13;
    - npm3+ and yarn manage node_modules through a flattened way, which solves some problems of nested ways, but introduces the problem of ghost dependencies, and only one version of the same package will be promoted, and the rest of the versions will still be copied multiple times.&#13;
    - pnpm hard links from the global store to node_modules/.pnpm, and then organizes the dependency relationship between them through soft links.&#13;
。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/230820-bi-ji--%20About%20pnpm.html</guid><pubDate>Tue, 05 Dec 2023 13:08:27 +0000</pubDate></item><item><title>Hello, world.</title><link>https://blog.chenkeyan.com/post/Hello%2C%20world..html</link><description>this article is created by github issue.。</description><guid isPermaLink="true">https://blog.chenkeyan.com/post/Hello%2C%20world..html</guid><pubDate>Fri, 01 Dec 2023 02:25:21 +0000</pubDate></item></channel></rss>