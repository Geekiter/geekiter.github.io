<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="//cdn.staticfile.net/Primer/21.0.7/primer.css" rel="stylesheet" />
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="240305Note: fe - React">
<title>240305Note: fe - React</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />

</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">240305Note: fe - React</h1>
<div class="title-right">
    
    <a href="https://blog.chenkeyan.com"><button id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </button></a>

    
    <a href="https://github.com/Geekiter/geekiter.github.io/issues/19" target="_blank"><button class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </button></a>
    

    <button class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </button>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>React</h2>
<h3>一、组件基础</h3>
<h4>1. React 事件机制</h4>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-c1">&lt;</span><span class="pl-ent">div</span>
	<span class="pl-c1">onClick</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">handleClick</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span><span class="pl-kos">}</span>
<span class="pl-c1">&gt;</span>
	点我
<span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">div</span><span class="pl-c1">&gt;</span></pre></div>
<p>react并不是将click事件绑定到div真实的dom上，而是在document处监听了所有的事件。当事件发生并且冒泡在document处时，react将事件内容封装并交给真正的处理函数处理，这样的方式不仅仅减少了内存的消耗，还能在挂件在销毁时统一订阅和移除事件。<br>
除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件。因此不想事件冒泡，应该调用event.preventDefault()方法，而不是调用event.stopPropagation()方法。<br>
So,</p>
<ul>
<li>react在document处监听了所有事件，当事件发生并冒泡到document，将事件内容封装成合成事件并交给真正的处理函数处理
<ul>
<li>没有将click事件绑定到真是的dom上，所以要用event.preventDefault()阻止事件冒泡，而不是event.stopPropagation()方法</li>
<li>好处：
<ul>
<li>减少了内存的消耗</li>
<li>让组件挂载销毁时统一订阅和移除事件</li>
<li>抹平浏览器之间的兼容性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h4>
<ul>
<li>高阶组件HOC是react用于复用组件逻辑的一种高级技巧。HOC自身不是React API的一部分，他是基于React的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">function</span> <span class="pl-en">withSubscription</span><span class="pl-kos">(</span><span class="pl-v">WrappedComponent</span><span class="pl-kos">,</span> <span class="pl-s1">selectData</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
	<span class="pl-k">return</span> <span class="pl-k">class</span> <span class="pl-s1">extend</span> <span class="pl-v">React</span><span class="pl-kos">.</span><span class="pl-v">Component</span> <span class="pl-kos">{</span>
		<span class="pl-en">constructor</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
			<span class="pl-smi">super</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
			<span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">state</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
				<span class="pl-c1">data</span>: <span class="pl-s1">selectData</span><span class="pl-kos">(</span><span class="pl-v">DataSource</span><span class="pl-kos">,</span> <span class="pl-s1">props</span><span class="pl-kos">)</span>
			<span class="pl-kos">}</span><span class="pl-kos">;</span>
		<span class="pl-kos">}</span>
		<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
			<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-v">WrappedComponent</span> <span class="pl-c1">data</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">state</span><span class="pl-kos">.</span><span class="pl-c1">data</span><span class="pl-kos">}</span> <span class="pl-kos">{</span>...<span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">props</span><span class="pl-kos">}</span><span class="pl-c1">/</span><span class="pl-c1">&gt;</span><span class="pl-kos">;</span>
		<span class="pl-kos">}</span>
	<span class="pl-kos">}</span>
<span class="pl-kos">}</span>
<span class="pl-k">const</span> <span class="pl-v">BlogPostWithSubscription</span> <span class="pl-c1">=</span> <span class="pl-en">withSubscription</span><span class="pl-kos">(</span><span class="pl-v">BlogPost</span><span class="pl-kos">,</span> <span class="pl-kos">(</span><span class="pl-v">DataSOurce</span><span class="pl-kos">,</span> <span class="pl-s1">props</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-v">DataSource</span><span class="pl-kos">.</span><span class="pl-en">getBLogPost</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">.</span><span class="pl-c1">id</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">;</span></pre></div>
<ul>
<li>render props是一种在React组件之间使用一个值为函数的prop共享代码的简单技术。render prop是一个用于告知组件需要渲染什么内容的函数prop</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"></pre></div>
<ul>
<li>
<p>通常，render props和高阶组件只渲染一个子节点。让Hook来服务这个使用场景更简单，Hook可以帮助减少桥套。</p>
</li>
<li>
<p>hoc、render props、hook都是为了解决代码复用的问题。</p>
</li>
<li>
<p>hoc接收一个组件和一个可选的参数，返回一个组件。通过包装现有的组件来添加新的行为和功能</p>
</li>
<li>
<p>render props接收一个返回react函数，将render的渲染注入到组件内部。父组件通过一个函数prop将渲染逻辑传给子组件，子组件通过函数获取渲染要渲染的内容。</p>
</li>
<li>
<p>hook是react16.8的新特性，可以使用状态useState、生命周期useEffect、上下文useContext</p>
</li>
</ul>
<h4>5. 对React-Fiber的理解，它解决了什么问题？</h4>
<ul>
<li>React 15在渲染是会递归对比虚拟Dom树，再出需要变动的节点，然后同步更新他们，一气呵成。这个过程React会占据浏览器资源，会导致用户触发的事件得不到响应，导致用户感觉卡顿。</li>
<li>React通过fiber架构让渲染过程可中断，让浏览器及时响应用户交互。</li>
<li>此外fiber还可以分批延时对DOM进行操作，避免一次性操作大量的DOM节点</li>
</ul>
<h4>9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景</h4>
<ul>
<li>高阶组件，输入为一个组件和一个可选参数，输出一个组件
<ul>
<li>场景
<ul>
<li>代码、状态逻辑复用</li>
<li>渲染劫持，权限控制</li>
</ul>
</li>
</ul>
</li>
<li>普通组件
<ul>
<li>场景
<ul>
<li>描述UI、功能单一、易于理解</li>
</ul>
</li>
<li>类组件
<ul>
<li>继承Component，输出组件</li>
</ul>
</li>
<li>函数组件
<ul>
<li>输入props，输出组件</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">function</span> <span class="pl-en">hoc</span><span class="pl-kos">(</span><span class="pl-s1">wrappedComponent</span><span class="pl-kos">,</span> <span class="pl-s1">optionalData</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
	<span class="pl-k">return</span> <span class="pl-k">class</span> <span class="pl-k">extends</span> <span class="pl-v">React</span><span class="pl-kos">.</span><span class="pl-c1">Component</span> <span class="pl-kos">{</span>
		<span class="pl-en">constructor</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
			<span class="pl-smi">super</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
			<span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">state</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
				<span class="pl-c1">data</span>: <span class="pl-s1">optionalData</span><span class="pl-kos">(</span><span class="pl-v">DataSource</span><span class="pl-kos">,</span> <span class="pl-s1">props</span><span class="pl-kos">)</span>
			<span class="pl-kos">}</span>
		<span class="pl-kos">}</span>
	<span class="pl-kos">}</span>

	<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos"></span><span class="pl-kos">{</span>
		<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-ent">WrappedComponent</span> <span class="pl-c1">data</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">state</span><span class="pl-kos">.</span><span class="pl-c1">data</span><span class="pl-kos">}</span> <span class="pl-kos">{</span>...<span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">props</span><span class="pl-kos">}</span><span class="pl-c1">/</span><span class="pl-c1">&gt;</span><span class="pl-kos">;</span>
	<span class="pl-kos">}</span>
<span class="pl-kos">}</span>

<span class="pl-k">const</span> <span class="pl-v">BlogPostWithSubscription</span> <span class="pl-c1">=</span> <span class="pl-en">hoc</span><span class="pl-kos">(</span><span class="pl-v">BlogPost</span><span class="pl-kos">,</span> <span class="pl-kos">(</span><span class="pl-v">DataSource</span><span class="pl-kos">,</span> <span class="pl-s1">props</span><span class="pl-kos">)</span><span class="pl-c1">=&gt;</span><span class="pl-v">DataSource</span><span class="pl-kos">.</span><span class="pl-en">getBlogPost</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">.</span><span class="pl-c1">id</span><span class="pl-kos">)</span><span class="pl-kos">)</span><span class="pl-kos">;</span>

<span class="pl-c">//普通组件</span>
<span class="pl-k">import</span> <span class="pl-v">React</span><span class="pl-kos">,</span> <span class="pl-kos">{</span><span class="pl-v">Component</span><span class="pl-kos">}</span> <span class="pl-k">from</span> <span class="pl-s">"react"</span><span class="pl-kos">;</span>

<span class="pl-k">class</span> <span class="pl-v">MyCompoent</span> <span class="pl-k">extends</span> <span class="pl-v">Component</span><span class="pl-kos">{</span>
	<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-ent">div</span><span class="pl-c1">&gt;</span>...<span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">div</span><span class="pl-c1">&gt;</span>
	<span class="pl-kos">}</span>

<span class="pl-kos">}</span>

<span class="pl-k">function</span> <span class="pl-v">MyCompoent</span><span class="pl-kos">(</span><span class="pl-s1">props</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
	<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-ent">div</span><span class="pl-c1">&gt;</span>...<span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">div</span><span class="pl-c1">&gt;</span>

<span class="pl-kos">}</span></pre></div>
<h4>11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h4>
<ul>
<li>哪些方法
<ul>
<li>State</li>
<li>Props</li>
<li>force update</li>
<li>生命周期方法</li>
<li>Context变化</li>
</ul>
</li>
<li>会做些什么
<ul>
<li>调用render生成虚拟dom</li>
<li>用Diff算法对新旧虚拟DOM节点进行对比
<ul>
<li>对新旧两棵树进行深度优先遍历，进行标记对比。更具差异类型和对应的规则更新变化部分的虚拟DOM节点</li>
</ul>
</li>
<li>生命周期调用</li>
</ul>
</li>
</ul>
<h4>14. 对有状态组件和无状态组件的理解及使用场景</h4>
<p>无状态一般是纯展示性的组件，简单UI。<br>
有状态适用于复杂UI和处理用户交互的组件。</p>
<h4>23. React中什么是受控组件和非控组件？</h4>
<ul>
<li>受控组件
<ul>
<li>受到state控制</li>
<li>用户与组件交互时，通常会触发事件来处理函数，更新组件state</li>
</ul>
</li>
<li>非受控组件
<ul>
<li>不受state控制</li>
<li>由DOM元素本身管理</li>
<li>在非受控组件中，可以使用ref来获取输入框的值</li>
</ul>
</li>
</ul>
<h4>28. 类组件与函数组件有什么异同？</h4>
<ul>
<li>
<p>不同</p>
<ul>
<li>生命周期
<ul>
<li>在react16.8之前，函数组件没有生命周期</li>
</ul>
</li>
<li>代码量，函数更轻量</li>
<li>性能，函数更快，但是微不足道</li>
<li>初始化状态，类组件在构造函数中进行，函数组件在useState hook来初始化状态</li>
</ul>
</li>
<li>
<p>共同</p>
<ul>
<li>用途，都是为了构建用户界面和定义组件行为</li>
<li>组件特性，都可以接受输入props</li>
<li>组件嵌套，都可以嵌套成组件树</li>
</ul>
</li>
</ul>
<p>23</p>
<h2>数据管理</h2>
<h4>1. React setState 调用的原理</h4>
<ul>
<li>首先调用setState入口函数，根据输入参数不同，分发到不同功能函数中去</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-v">ReactComponent</span><span class="pl-kos">.</span><span class="pl-c1">prototype</span><span class="pl-kos">.</span><span class="pl-en">setState</span> <span class="pl-c1">=</span> <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">partialState</span><span class="pl-kos">,</span> <span class="pl-s1">callback</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
	<span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">updater</span><span class="pl-kos">.</span><span class="pl-en">enqueueSetState</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">,</span> <span class="pl-s1">partialState</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-k">if</span> <span class="pl-kos">(</span><span class="pl-s1">callback</span><span class="pl-kos">)</span> <span class="pl-kos">{</span>
		<span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">updater</span><span class="pl-kos">.</span><span class="pl-en">enqueueCallback</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">,</span> <span class="pl-s1">callback</span><span class="pl-kos">,</span> <span class="pl-s">"setState"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-kos">}</span>
<span class="pl-kos">}</span></pre></div>
<ul>
<li>enqueueSetState将新的state放进组件的状态队列，调用enqueeUpdate来处理将要更新的实例</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate">enqueueSetState: <span class="pl-k">function</span><span class="pl-kos">(</span><span class="pl-s1">publicInstance</span><span class="pl-kos">,</span> <span class="pl-s1">partialState</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
	<span class="pl-k">var</span> <span class="pl-s1">internalInstance</span> <span class="pl-c1">=</span> <span class="pl-en">getInternalInstanceReadyForUpdate</span><span class="pl-kos">(</span><span class="pl-s1">publicInstance</span><span class="pl-kos">,</span> <span class="pl-s">"setState"</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-k">var</span> <span class="pl-s1">queue</span> <span class="pl-c1">=</span> <span class="pl-s1">internalInstance</span><span class="pl-kos">.</span><span class="pl-c1">_pendingStateQueue</span><span class="pl-c1">||</span><span class="pl-kos">(</span><span class="pl-s1">internalInstance</span><span class="pl-kos">.</span><span class="pl-c1">_pendingStateQueue</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-kos">]</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-s1">queue</span><span class="pl-kos">.</span><span class="pl-en">push</span><span class="pl-kos">(</span><span class="pl-s1">partialState</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-en">enqueueUpdate</span><span class="pl-kos">(</span><span class="pl-s1">internalInstance</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-kos">}</span></pre></div>
<ul>
<li>在enqueueUpdate方法引出一个关键的对象batchingStrategy，该对象所具备的isBatchingUpdates属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用batchUpdates方法发起更新流程。由此可以推测，batchingStrategy或许正是React内部专用于批量更新的对象</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">function</span> <span class="pl-en">enqueueUpdate</span><span class="pl-kos">(</span><span class="pl-s1">component</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
	<span class="pl-en">ensureInjected</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-k">if</span><span class="pl-kos">(</span><span class="pl-c1">!</span><span class="pl-s1">batchingStrategy</span><span class="pl-kos">.</span><span class="pl-c1">isBatchingUpdates</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-s1">batchingStrategy</span><span class="pl-kos">.</span><span class="pl-en">batchedUpdates</span><span class="pl-kos">(</span><span class="pl-s1">enqueueUpdate</span><span class="pl-kos">,</span> <span class="pl-s1">component</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
		<span class="pl-k">return</span>
	<span class="pl-kos">}</span>
	<span class="pl-s1">dirtyComponents</span><span class="pl-kos">.</span><span class="pl-en">push</span><span class="pl-kos">(</span><span class="pl-s1">component</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
	<span class="pl-k">if</span><span class="pl-kos">(</span><span class="pl-s1">component</span><span class="pl-kos">.</span><span class="pl-c1">_updateBatchNUmber</span> <span class="pl-c1">==</span> <span class="pl-c1">null</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-s1">component</span><span class="pl-kos">.</span><span class="pl-c1">_updateBatchNumber</span> <span class="pl-c1">=</span> <span class="pl-s1">updateBatchNumber</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span><span class="pl-kos">;</span>
	<span class="pl-kos">}</span>
<span class="pl-kos">}</span></pre></div>
<ul>
<li>setState</li>
<li>enqueueSetState：将新的状态放入组件的状态队列，调用enqueueUpdate来处理要更新的视力</li>
<li>enqueueUpdate</li>
<li>isBatchingUpdates，是否批量创建/更新组件
<ul>
<li>true: dirtyComponent，更新组件</li>
<li>false: dirtyComponents，推入组件</li>
</ul>
</li>
</ul>
<h4>2. React setState 调用之后发生了什么？是同步还是异步？</h4>
<p>在代码中调用setState，React会将传入的参数对象与组件当前的状态合并，然后触发调和过程，经过调和过程。React会以相对高效的方式根据新的状态React元素树并且着手重新渲染整个UI界面。<br>
React得到元素树之后，React会自动计算出新的树和老树的节点差异，然后根据差异对界面进行最小化重新渲染。在差异计算算法中，React能够精确地知道哪些位置发生了改变以及如何改变，这就保证了按需更新，而不是重新渲染。如果短时间频繁setState，React会将state的改变压入栈，在合适的时机，批量更新state和视图，达到提高性能的效果。</p>
<ul>
<li>React将输入和组件当前的状态合并，触发调和过程</li>
<li>得到新的元素树</li>
<li>计算新老树的差异</li>
<li>按需更新</li>
<li>如果短时间频繁setState，将state改变压入栈，在合适的时机批量更新state和视图</li>
</ul>
<h4>7. 在React中组件的this.state和setState有什么区别？</h4>
<p>this.state通常是用来初始化state，setState是用来修改state值的。如果直接修改state页面是不会更新的。</p>
<h4>9. React组件的state和props有什么区别？</h4>
<ul>
<li>props是传递给函数的形参，state是组件内自己管理的变量</li>
<li>props是不可以被修改的，react要不好props不能被修改</li>
<li>state是在组件中创建的，一般在constructor中初始化</li>
</ul>
<h3>三、生命周期</h3>
<h4>1. React的生命周期有哪些？</h4>
<ul>
<li>装载阶段Mount
<ul>
<li>constructor 用来创建组件</li>
<li>render，渲染返回需要渲染的内容</li>
<li>componentDidMount，挂在完成后执行</li>
</ul>
</li>
<li>更新阶段Update
<ul>
<li>给组件创建props、setState、forceUpdate都会重新调用render函数，</li>
<li>更新完成后执行componentDidUpdate</li>
</ul>
</li>
<li>卸载过程Unmount
<ul>
<li>移除完成执行componentWillUnmount</li>
</ul>
</li>
</ul>
<h3>四、组件通信</h3>
<h4>1. 父子组件的通信方式？</h4>
<ul>
<li>父到子
<ul>
<li>props</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">Child</span> <span class="pl-c1">=</span> <span class="pl-s1">props</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
	<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-ent">p</span><span class="pl-c1">&gt;</span><span class="pl-kos">{</span><span class="pl-s1">props</span><span class="pl-kos">.</span><span class="pl-c1">name</span><span class="pl-kos">}</span><span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">p</span><span class="pl-c1">&gt;</span>
<span class="pl-kos">}</span>
<span class="pl-k">const</span> <span class="pl-v">Parent</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
	<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-v">Child</span> <span class="pl-c1">name</span><span class="pl-c1">=</span><span class="pl-s">"rect"</span><span class="pl-c1">&gt;</span><span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-v">Child</span><span class="pl-c1">&gt;</span>
<span class="pl-kos">}</span></pre></div>
<ul>
<li>子到父
<ul>
<li>props+回调</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">Child</span> <span class="pl-c1">=</span> <span class="pl-s1">props</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
	<span class="pl-k">const</span> <span class="pl-en">cb</span> <span class="pl-c1">=</span> <span class="pl-s1">msg</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
		<span class="pl-k">return</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
			<span class="pl-s1">props</span><span class="pl-kos">.</span><span class="pl-en">callback</span><span class="pl-kos">(</span><span class="pl-s1">msg</span><span class="pl-kos">)</span>
		<span class="pl-kos">}</span>
	<span class="pl-kos">}</span>
	<span class="pl-k">return</span> <span class="pl-kos">{</span>
		<span class="pl-c1">&lt;</span><span class="pl-ent">button</span> <span class="pl-c1">onClick</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-en">cb</span><span class="pl-kos">(</span><span class="pl-s">"你好"</span><span class="pl-kos">)</span><span class="pl-kos">}</span><span class="pl-c1">&gt;</span>你好<span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">button</span><span class="pl-c1">&gt;</span>
	<span class="pl-kos">}</span>
<span class="pl-kos">}</span>

<span class="pl-k">class</span> <span class="pl-v">Parent</span> <span class="pl-k">extends</span> <span class="pl-v">Component</span> <span class="pl-kos">{</span>
	<span class="pl-en">callback</span><span class="pl-kos">(</span><span class="pl-s1">msg</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-smi">console</span><span class="pl-kos">.</span><span class="pl-en">log</span><span class="pl-kos">(</span><span class="pl-s1">msg</span><span class="pl-kos">)</span>
	<span class="pl-kos">}</span>
	<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-k">return</span> <span class="pl-c1">&lt;</span><span class="pl-v">Child</span> <span class="pl-c1">callback</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">callback</span><span class="pl-kos">.</span><span class="pl-en">bind</span><span class="pl-kos">(</span><span class="pl-smi">this</span><span class="pl-kos">)</span><span class="pl-kos">}</span><span class="pl-c1">&gt;</span><span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-v">Child</span><span class="pl-c1">&gt;</span>
	<span class="pl-kos">}</span>
	
<span class="pl-kos">}</span></pre></div>
<h4>2. 跨级组件的通信方式？</h4>
<p>父组件向子组件的子组件通信，向更深层子组件通信：</p>
<ul>
<li>props</li>
<li>context</li>
</ul>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">const</span> <span class="pl-v">BatteryContext</span> <span class="pl-c1">=</span> <span class="pl-en">createContext</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">;</span>
<span class="pl-c">// 子组件的子组件</span>
<span class="pl-k">class</span> <span class="pl-v">GrandChild</span> <span class="pl-k">extends</span> <span class="pl-v">Component</span> <span class="pl-kos">{</span>
	<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-k">return</span> <span class="pl-kos">(</span>
			<span class="pl-c1">&lt;</span><span class="pl-v">BatteryContext</span><span class="pl-kos">.</span><span class="pl-v">Consumer</span><span class="pl-c1">&gt;</span>
				<span class="pl-kos">{</span>
					<span class="pl-s1">color</span> <span class="pl-c1">=&gt;</span> <span class="pl-c1">&lt;</span><span class="pl-ent">h1</span>
	<span class="pl-c1">style</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-kos">{</span><span class="pl-s">"color"</span>: <span class="pl-s1">color</span><span class="pl-kos">}</span><span class="pl-kos">}</span><span class="pl-c1">我是红色的：</span><span class="pl-kos">{</span><span class="pl-s1">color</span><span class="pl-kos">}</span><span class="pl-c1">&gt;</span><span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">h1</span><span class="pl-c1">&gt;</span>
				<span class="pl-kos">}</span>
			<span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-v">BatteryContext</span><span class="pl-kos">.</span><span class="pl-v">Consumer</span><span class="pl-c1">&gt;</span>
		
		<span class="pl-kos">)</span>
	<span class="pl-kos">}</span>
<span class="pl-kos">}</span>

<span class="pl-c">// 子组件</span>
<span class="pl-k">const</span> <span class="pl-v">Child</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
	<span class="pl-k">return</span> <span class="pl-kos">(</span>
		<span class="pl-c1">&lt;</span><span class="pl-ent">GrandChild</span><span class="pl-c1">/</span><span class="pl-c1">&gt;</span>
	<span class="pl-kos">)</span>
<span class="pl-kos">}</span>

<span class="pl-c">// 父组件</span>
<span class="pl-k">class</span> <span class="pl-v">Parent</span> <span class="pl-k">extends</span> <span class="pl-v">Component</span> <span class="pl-kos">{</span>
	<span class="pl-c1">state</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span>
		<span class="pl-c1">color</span>: <span class="pl-s">"red"</span>
	<span class="pl-kos">}</span>
	<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
		<span class="pl-k">const</span> <span class="pl-kos">{</span>color<span class="pl-kos">}</span> <span class="pl-c1">=</span> <span class="pl-smi">this</span><span class="pl-kos">.</span><span class="pl-c1">state</span><span class="pl-kos">;</span>
		<span class="pl-k">return</span> <span class="pl-kos">(</span>
			<span class="pl-c1">&lt;</span><span class="pl-v">BatteryContext</span><span class="pl-kos">.</span><span class="pl-v">Provider</span> <span class="pl-c1">value</span><span class="pl-c1">=</span><span class="pl-kos">{</span><span class="pl-s1">color</span><span class="pl-kos">}</span><span class="pl-c1">&gt;</span>
				<span class="pl-c1">&lt;</span><span class="pl-v">Child</span><span class="pl-c1">&gt;</span><span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-v">Child</span><span class="pl-c1">&gt;</span>
			<span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-v">BatteryContext</span><span class="pl-kos">.</span><span class="pl-v">Provider</span><span class="pl-c1">&gt;</span>
		<span class="pl-kos">)</span>
	<span class="pl-kos">}</span>

<span class="pl-kos">}</span></pre></div>
<h4>3. 非嵌套关系组件的通信方式？</h4>
<ul>
<li>事件通信，订阅模式</li>
<li>redux全局状态管理</li>
<li>兄弟之间可以找到共同的父节点通信</li>
</ul>
<h4>5. 组件通信的方式有哪些</h4>
<ul>
<li>props</li>
<li>props+回调</li>
<li>Context</li>
<li>订阅模式</li>
<li>全局状态管理</li>
</ul>
<h3>五、路由</h3>
<h4>1. React-Router的实现原理是什么？</h4>
<ul>
<li>hash模式
<ul>
<li>监听hashchange</li>
</ul>
</li>
<li>history
<ul>
<li>监听url变化</li>
</ul>
</li>
</ul>
<h4>7. React-Router的路由有几种模式？</h4>
<ul>
<li>history的BrowserRouter模式</li>
<li>HashRouter模式</li>
</ul>
<h3>六、Redux</h3>
<h4>1. 对 Redux 的理解，主要解决什么问题</h4>
<p>react是视图层框架，redux是一个用来管理数据状态和UI状态的js应用工具。随着js单页应用变得复杂，js需要更多状态，redux就是为了降低管理难度的。<br>
在redux中，提供了一个叫store的统一仓储库，组件通过dispatch将state直接传入store，不用通过其他组件。并且组件通过subscribe从store获取到state的改变，使用了redux，所有的组件都可以从store获取到所需的state，他们也能从store获取到state的改变。<br>
解决的问题：react-redux的作用是将redux的状态机和react的ui绑定在一起，当你dispatch action改变state的时候，会自动更新页面。</p>
<h4>2. Redux 原理及工作流程</h4>
<p>工作流程</p>
<ol>
<li>view通过dispatch发出action</li>
<li>store调用reducer，传入state、action，reduce返回新的state</li>
<li>state有了变化，store调用监听函数，更新view</li>
</ol>
<h4>9. Redux 和 Vuex 有什么区别，它们的共同思想</h4>
<ul>
<li>区别
<ul>
<li>vuex改进了redux的action和reducer函数，以及mutations变化函数取代reducer，无需switch，只需要在对应的mutation函数里改变state值即可</li>
<li>vuex由于vue自动重新渲染的特性，无需订阅。</li>
<li>vuex数据流的顺序是view调用store.commit提交对应的请求到store中对应的mutation函数到store改变</li>
</ul>
</li>
<li>共同思想
<ul>
<li>单一数据源</li>
<li>变化可以预测</li>
</ul>
</li>
</ul>
<h3>七、Hooks</h3>
<h4>1. 对 React Hook 的理解，它的实现原理是什么</h4>
<p>hook让组件实现变得更加简洁。<br>
闭包</p>
<h4>2. 为什么 useState 要使用数组而不是对象</h4>
<ul>
<li>简洁</li>
<li>对象需要起别名</li>
</ul>
<h4>3. React Hooks 解决了哪些问题？</h4>
<ul>
<li>组件之间复用状态逻辑困难的问题</li>
<li>复杂组件难以理解</li>
<li>class难以理解</li>
</ul>
<h3>八、虚拟DOM</h3>
<h4>1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？</h4>
<p>虚拟DOM是一个React的优化手段，通过在内存中维护一份轻量的DOM副本，实现更高效的渲染和更新机制。<br>
工作流程：</p>
<ul>
<li>状态更新</li>
<li>虚拟DOM表示</li>
<li>差异计算</li>
<li>实际DOM操作<br>
虚拟DOM本身是一个内存中的表示真实DOM结构的js对象树，用于提高渲染的性能和优化DOM操作。</li>
</ul>
<h4>2. React diff 算法的原理是什么？</h4>
<p>diff算法是为了找出新旧虚拟DOM之间的差异，以最小化对实际DOM的操作。<br>
算法的核心：</p>
<ul>
<li>同层比较，不跨层级比较</li>
<li>节点类型比较，如果节点类型不同，就会将节点和子节点全部替换，不会再深入比较子节点</li>
<li>唯一key标识，比较完节点类型，再比较节点属性，如果节点有唯一的key标识，react会尽量复用这个节点</li>
<li>递归比较子节点，没有唯一key标识，会递归比较子节点的差异。</li>
<li>列表节点优化，处理列表时，会通过判断位移、删除和添加来最小化操作。</li>
</ul>
<h3>九、其他</h3>
<h4>5. 对 React 和 Vue 的理解，它们的异同</h4>
<ul>
<li>相似
<ul>
<li>将重心都放在核心库，将其他功能比如路由和全局状态交给其他库</li>
<li>都有自己的构建工具，得到一个最佳实践的项目模板</li>
<li>都使用虚拟DOM重绘性能</li>
<li>都有props概念，允许组件间的数据传递</li>
<li>都鼓励组件化，提高复用性</li>
</ul>
</li>
<li>不同
<ul>
<li>数据流
<ul>
<li>Vue默认支持数据双向绑定，React提倡单向数据流</li>
<li>虚拟DOM
<ul>
<li>Vue会根据每个组件的依赖关系，而不会重新渲染整个组件树</li>
<li>React的全部子组件都会重新渲染，当然可以通过PureComponent/ShouldComponentUpdate这个生命周期方法来控制</li>
</ul>
</li>
<li>组件化
<ul>
<li>Vue默认使用HTML模板</li>
<li>React推荐使用JSX</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4>12. 在React中遍历的方法有哪些？</h4>
<p>遍历数组，map&amp;&amp;forEach</p>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-s1">arr</span><span class="pl-kos">.</span><span class="pl-en">map</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">item</span><span class="pl-kos">,</span> <span class="pl-s1">index</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>
	
<span class="pl-kos">}</span><span class="pl-kos">)</span>

<span class="pl-s1">arr</span><span class="pl-kos">.</span><span class="pl-en">forEach</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">item</span><span class="pl-kos">,</span> <span class="pl-s1">index</span><span class="pl-kos">)</span> <span class="pl-c1">=&gt;</span> <span class="pl-kos">{</span>

<span class="pl-kos">}</span><span class="pl-kos">)</span></pre></div>
<p>遍历对象，map for in</p>
<div class="highlight highlight-source-js"><pre class="notranslate"><span class="pl-k">for</span><span class="pl-kos">(</span><span class="pl-k">const</span> <span class="pl-s1">key</span> <span class="pl-k">in</span> <span class="pl-s1">obj</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
	<span class="pl-k">if</span><span class="pl-kos">(</span><span class="pl-s1">obj</span><span class="pl-kos">.</span><span class="pl-en">hasOwnProperty</span><span class="pl-kos">(</span><span class="pl-s1">key</span><span class="pl-kos">)</span><span class="pl-kos"></span><span class="pl-kos">{</span>
		<span class="pl-k">const</span> <span class="pl-s1">value</span> <span class="pl-c1">=</span> <span class="pl-s1">obj</span><span class="pl-kos">[</span><span class="pl-s1">key</span><span class="pl-kos">]</span>
		<span class="pl-s1">domArr</span><span class="pl-kos">.</span><span class="pl-en">push</span><span class="pl-kos">(</span>...<span class="pl-kos">)</span>
	<span class="pl-kos">}</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>

<span class="pl-v">Object</span><span class="pl-kos">.</span><span class="pl-en">entries</span><span class="pl-kos">(</span><span class="pl-s1">obj</span><span class="pl-kos">)</span><span class="pl-kos">.</span><span class="pl-en">map</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-kos">[</span><span class="pl-s1">key</span><span class="pl-kos">,</span> <span class="pl-s1">value</span><span class="pl-kos">]</span><span class="pl-kos">,</span> <span class="pl-s1">index</span><span class="pl-kos">)</span><span class="pl-c1">=&gt;</span><span class="pl-kos">{</span>

<span class="pl-kos">}</span><span class="pl-kos">)</span></pre></div>
<h4>19. 对React SSR的理解</h4>
<p>服务端渲染是数据与模板组成的html，即html=数据+模板。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记混合为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body为空，之后执行js将html结构注入到body里，结合css显示出来</p>
<ul>
<li>好处：
<ul>
<li>SEO友好</li>
<li>资源都存储在服务器端</li>
<li>响应亏，体验好，首屏渲染快</li>
</ul>
</li>
<li>局限性
<ul>
<li>服务端压力大</li>
<li>开发条件受限</li>
</ul>
</li>
</ul>
<h4>20. 为什么 React 要用 JSX？</h4>
<p>react并没有强制使用jsx，jsx类似一种语法糖，代码更为简洁和清晰。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>
<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>
</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://blog.chenkeyan.com"> Geekiter </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if(""!=""){
    var now=new Date();
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);

function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","Geekiter/geekiter.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>



</html>
